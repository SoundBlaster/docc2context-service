{"schemaVersion":{"major":0,"minor":3,"patch":0},"seeAlsoSections":[{"title":"Related Documentation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AutoContextMacro","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"anchor":"Related-Documentation"},{"title":"Macros","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AutoContextMacro"],"generated":true,"anchor":"Macros"}],"identifier":{"url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/specificationcore\/specsmacro"]}],"sections":[],"abstract":[{"type":"text","text":"A macro that generates composite specifications by combining multiple specification instances with AND logic."}],"topicSections":[{"title":"Related Macros","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AutoContextMacro"],"anchor":"Related-Macros"},{"title":"Related Types","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"anchor":"Related-Types"}],"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"kind":"article","metadata":{"roleHeading":"API Collection","title":"@specs Macro","modules":[{"name":"SpecificationCore"}],"role":"collectionGroup"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"@specs","type":"codeVoice"},{"text":" macro simplifies creating composite specifications by automatically combining multiple specification instances using ","type":"text"},{"code":".and()","type":"codeVoice"},{"text":" logic. Instead of manually chaining specifications together, you can declare a specification type with the ","type":"text"},{"code":"@specs","type":"codeVoice"},{"text":" macro and let it generate all the boilerplate code for you.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"text":"Key Benefits","anchor":"Key-Benefits"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Automatic Composition","type":"text"}]},{"text":": Generates ","type":"text"},{"type":"codeVoice","code":".and()"},{"text":" chains automatically from specification instances","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Type-Safe"}]},{"type":"text","text":": Validates that all specifications share the same context type"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Compile-Time Validation"}]},{"type":"text","text":": Catches errors like mixed context types and incorrect arguments"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Reduced Boilerplate"}]},{"text":": Eliminates repetitive composite specification code","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Clear Intent"}]},{"text":": Declarative syntax makes complex rules easy to understand","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Auto Context Integration"}]},{"text":": Works seamlessly with ","type":"text"},{"type":"codeVoice","code":"AutoContext"},{"text":" macro","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","level":3,"text":"When to Use @specs","anchor":"When-to-Use-specs"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"code":"@specs","type":"codeVoice"},{"text":" when you need to:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"Combine multiple specifications with AND logic","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Create reusable composite specification types","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Define complex business rules declaratively","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduce boilerplate in specification-heavy code"}]}]},{"content":[{"inlineContent":[{"text":"Build eligibility or validation specifications","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Quick Example","anchor":"Quick-Example","type":"heading","level":2},{"code":["import SpecificationCore","","\/\/ Without @specs - manual composition","struct PremiumEligibilitySpec: Specification {","    typealias T = EvaluationContext","","    let spec1 = FeatureFlagSpec(flagKey: \"premium_enabled\")","    let spec2 = TimeSinceEventSpec(eventKey: \"user_registered\", days: 30)","    let spec3 = MaxCountSpec(counterKey: \"violations\", maximumCount: 1)","","    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {","        return spec1.and(spec2).and(spec3).isSatisfiedBy(candidate)","    }","}","","\/\/ With @specs - automatic composition","@specs(","    FeatureFlagSpec(flagKey: \"premium_enabled\"),","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 30),","    MaxCountSpec(counterKey: \"violations\", maximumCount: 1)",")","struct PremiumEligibilitySpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","level":2,"text":"How @specs Works","anchor":"How-specs-Works"},{"inlineContent":[{"type":"text","text":"The macro generates the necessary boilerplate to combine specifications:"}],"type":"paragraph"},{"code":["@specs(Spec1(), Spec2(), Spec3())","struct MyCompositeSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Expands to:","struct MyCompositeSpec: Specification {","    typealias T = EvaluationContext","","    private let composite: AnySpecification<T>","","    public init() {","        let specChain = Spec1().and(Spec2()).and(Spec3())","        self.composite = AnySpecification(specChain)","    }","","    public func isSatisfiedBy(_ candidate: T) -> Bool {","        composite.isSatisfiedBy(candidate)","    }","","    public func isSatisfiedByAsync(_ candidate: T) async throws -> Bool {","        composite.isSatisfiedBy(candidate)","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Usage Examples","level":2,"anchor":"Usage-Examples"},{"text":"Basic Eligibility Specification","anchor":"Basic-Eligibility-Specification","type":"heading","level":3},{"type":"codeListing","code":["@specs(","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 7),","    FeatureFlagSpec(flagKey: \"email_verified\"),","    MaxCountSpec(counterKey: \"violations\", maximumCount: 0)",")","struct RewardEligibilitySpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Usage","let spec = RewardEligibilitySpec()","let context = DefaultContextProvider.shared.currentContext()","","if spec.isSatisfiedBy(context) {","    grantReward()","}"],"syntax":"swift"},{"level":3,"anchor":"API-Access-Control","text":"API Access Control","type":"heading"},{"type":"codeListing","syntax":"swift","code":["@specs(","    MaxCountSpec.dailyLimit(\"api_calls\", limit: 1000),","    FeatureFlagSpec(flagKey: \"api_access_enabled\"),","    CooldownIntervalSpec.hourly(\"rate_limit_violation\").not()",")","struct APIAccessSpec: Specification {","    typealias T = EvaluationContext","}","","func makeAPICall() throws {","    let spec = APIAccessSpec()","    let context = DefaultContextProvider.shared.currentContext()","","    guard spec.isSatisfiedBy(context) else {","        throw APIError.accessDenied","    }","","    \/\/ Make API call","}"]},{"level":3,"anchor":"Feature-Rollout-Specification","text":"Feature Rollout Specification","type":"heading"},{"code":["@specs(","    FeatureFlagSpec(flagKey: \"new_feature_enabled\"),","    DateRangeSpec(start: rolloutStart, end: rolloutEnd),","    UserSegmentSpec(expectedSegment: .beta)",")","struct NewFeatureAccessSpec: Specification {","    typealias T = EvaluationContext","}","","@Satisfies(using: NewFeatureAccessSpec())","var canAccessNewFeature: Bool","","if canAccessNewFeature {","    showNewFeature()","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Premium-Subscription-Validation","level":3,"type":"heading","text":"Premium Subscription Validation"},{"syntax":"swift","code":["@specs(","    FeatureFlagSpec(flagKey: \"subscription_active\"),","    DateComparisonSpec(","        eventKey: \"subscription_start\",","        comparison: .before,","        date: Date().addingTimeInterval(365 * 86400)  \/\/ Within 1 year","    ),","    MaxCountSpec(counterKey: \"payment_failures\", maximumCount: 0)",")","struct ActiveSubscriptionSpec: Specification {","    typealias T = EvaluationContext","}","","func checkSubscriptionAccess() -> Bool {","    let spec = ActiveSubscriptionSpec()","    let context = DefaultContextProvider.shared.currentContext()","    return spec.isSatisfiedBy(context)","}"],"type":"codeListing"},{"anchor":"Combining-with-AutoContext","level":2,"type":"heading","text":"Combining with @AutoContext"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"@specs"},{"text":" macro works seamlessly with ","type":"text"},{"type":"codeVoice","code":"AutoContext"},{"text":" for even cleaner code:","type":"text"}]},{"syntax":"swift","code":["@specs(","    FeatureFlagSpec(flagKey: \"premium_enabled\"),","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 30),","    MaxCountSpec.dailyLimit(\"premium_actions\", limit: 100)",")","@AutoContext","struct PremiumAccessSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Usage with auto-context - no provider needed!","let spec = PremiumAccessSpec()","","\/\/ Access isSatisfied property (added by @AutoContext)","if try await spec.isSatisfied {","    enablePremiumFeatures()","}"],"type":"codeListing"},{"anchor":"Real-World-Examples","level":2,"type":"heading","text":"Real-World Examples"},{"anchor":"Multi-Tier-Access-Control","level":3,"type":"heading","text":"Multi-Tier Access Control"},{"syntax":"swift","code":["\/\/ Free tier - basic checks only","@specs(","    FeatureFlagSpec(flagKey: \"free_tier_enabled\"),","    MaxCountSpec.dailyLimit(\"free_actions\", limit: 10)",")","struct FreeTierSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Premium tier - more permissive","@specs(","    FeatureFlagSpec(flagKey: \"premium_subscription\"),","    MaxCountSpec.dailyLimit(\"premium_actions\", limit: 1000),","    DateComparisonSpec(","        eventKey: \"subscription_start\",","        comparison: .before,","        date: Date()","    )",")","struct PremiumTierSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Enterprise tier - most permissive","@specs(","    FeatureFlagSpec(flagKey: \"enterprise_subscription\"),","    MaxCountSpec.dailyLimit(\"enterprise_actions\", limit: 100000),","    FeatureFlagSpec(flagKey: \"priority_support\")",")","struct EnterpriseTierSpec: Specification {","    typealias T = EvaluationContext","}","","func getAccessLevel() -> AccessLevel {","    let context = DefaultContextProvider.shared.currentContext()","","    if EnterpriseTierSpec().isSatisfiedBy(context) {","        return .enterprise","    } else if PremiumTierSpec().isSatisfiedBy(context) {","        return .premium","    } else if FreeTierSpec().isSatisfiedBy(context) {","        return .free","    } else {","        return .none","    }","}"],"type":"codeListing"},{"anchor":"Campaign-Eligibility-System","level":3,"type":"heading","text":"Campaign Eligibility System"},{"syntax":"swift","code":["@specs(","    DateRangeSpec(start: campaignStart, end: campaignEnd),","    UserSegmentSpec(expectedSegment: .targetAudience),","    MaxCountSpec(counterKey: \"campaign_participations\", maximumCount: 0),","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 7),","    FeatureFlagSpec(flagKey: \"campaign_active\")",")","struct CampaignEligibilitySpec: Specification {","    typealias T = EvaluationContext","}","","func checkCampaignEligibility() -> (eligible: Bool, reason: String?) {","    let spec = CampaignEligibilitySpec()","    let context = DefaultContextProvider.shared.currentContext()","","    let eligible = spec.isSatisfiedBy(context)","","    if !eligible {","        \/\/ Check individual conditions to provide feedback","        if !DateRangeSpec(start: campaignStart, end: campaignEnd)","            .isSatisfiedBy(context) {","            return (false, \"Campaign is not currently active\")","        }","        if !TimeSinceEventSpec(eventKey: \"user_registered\", days: 7)","            .isSatisfiedBy(context) {","            return (false, \"Account must be at least 7 days old\")","        }","        return (false, \"Not eligible for this campaign\")","    }","","    return (true, nil)","}"],"type":"codeListing"},{"anchor":"Security-Gate-Specification","level":3,"type":"heading","text":"Security Gate Specification"},{"syntax":"swift","code":["@specs(","    FeatureFlagSpec(flagKey: \"account_verified\"),","    FeatureFlagSpec(flagKey: \"two_factor_enabled\"),","    MaxCountSpec(counterKey: \"failed_login_attempts\", maximumCount: 3),","    CooldownIntervalSpec(eventKey: \"last_password_change\", days: 90).not(),","    MaxCountSpec(counterKey: \"security_violations\", maximumCount: 0)",")","struct HighSecurityAccessSpec: Specification {","    typealias T = EvaluationContext","}","","func canAccessSensitiveData() -> Bool {","    let spec = HighSecurityAccessSpec()","    let context = DefaultContextProvider.shared.currentContext()","    return spec.isSatisfiedBy(context)","}","","func performSensitiveOperation() throws {","    guard canAccessSensitiveData() else {","        throw SecurityError.insufficientPermissions","    }","","    \/\/ Perform operation","}"],"type":"codeListing"},{"anchor":"Content-Moderation-Specification","level":3,"type":"heading","text":"Content Moderation Specification"},{"syntax":"swift","code":["@specs(","    FeatureFlagSpec(flagKey: \"account_in_good_standing\"),","    MaxCountSpec(counterKey: \"content_warnings\", maximumCount: 2),","    MaxCountSpec(counterKey: \"community_reports\", maximumCount: 5),","    TimeSinceEventSpec(eventKey: \"last_violation\", days: 30),","    CooldownIntervalSpec(eventKey: \"last_suspension\", days: 90)",")","struct CanPostContentSpec: Specification {","    typealias T = EvaluationContext","}","","func validateUserCanPost() -> PostPermission {","    let spec = CanPostContentSpec()","    let context = DefaultContextProvider.shared.currentContext()","","    if spec.isSatisfiedBy(context) {","        return .allowed","    } else {","        return .restricted(reason: \"Account restrictions in effect\")","    }","}"],"type":"codeListing"},{"anchor":"Validation-and-Diagnostics","level":2,"type":"heading","text":"Validation and Diagnostics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"@specs","type":"codeVoice"},{"type":"text","text":" macro provides compile-time validation:"}]},{"anchor":"Requires-Specification-Conformance","level":3,"type":"heading","text":"Requires Specification Conformance"},{"syntax":"swift","code":["\/\/ ❌ Error - must conform to Specification","@specs(Spec1(), Spec2())","struct MySpec {  \/\/ Missing: Specification","    typealias T = EvaluationContext","}"],"type":"codeListing"},{"anchor":"Requires-At-Least-One-Argument","level":3,"type":"heading","text":"Requires At Least One Argument"},{"syntax":"swift","type":"codeListing","code":["\/\/ ❌ Error - requires at least one specification","@specs()","struct EmptySpec: Specification {","    typealias T = EvaluationContext","}"]},{"type":"heading","level":3,"text":"Warns About Missing typealias T","anchor":"Warns-About-Missing-typealias-T"},{"syntax":"swift","type":"codeListing","code":["\/\/ ⚠️ Warning - should add typealias T","@specs(Spec1(), Spec2())","struct MySpec: Specification {","    \/\/ Missing: typealias T = EvaluationContext","}"]},{"type":"heading","level":3,"text":"Detects Mixed Context Types","anchor":"Detects-Mixed-Context-Types"},{"syntax":"swift","type":"codeListing","code":["\/\/ ❌ Error - mixed context types","@specs(","    MaxCountSpec(counterKey: \"count\", maximumCount: 10),  \/\/ EvaluationContext","    CustomSpec<OtherContext>()                             \/\/ OtherContext",")","struct MixedSpec: Specification {","    typealias T = EvaluationContext","}"]},{"type":"heading","level":3,"text":"Prevents Async Specifications","anchor":"Prevents-Async-Specifications"},{"syntax":"swift","type":"codeListing","code":["\/\/ ❌ Error - async specifications not supported","@specs(","    MaxCountSpec(counterKey: \"count\", maximumCount: 10),","    SomeAsyncSpec()  \/\/ AsyncSpecification not allowed",")","struct MySpec: Specification {","    typealias T = EvaluationContext","}"]},{"anchor":"Warns-About-Type-References","type":"heading","text":"Warns About Type References","level":3},{"type":"codeListing","code":["\/\/ ⚠️ Warning - looks like a type reference","@specs(","    MaxCountSpec.self,  \/\/ Should be MaxCountSpec(...)","    FeatureFlagSpec.self",")","struct MySpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"anchor":"Testing","type":"heading","text":"Testing","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test macro-generated specifications like any other:"}]},{"type":"codeListing","code":["func testCompositeSpecification() {","    @specs(","        FeatureFlagSpec(flagKey: \"enabled\"),","        MaxCountSpec(counterKey: \"count\", maximumCount: 10)","    )","    struct TestSpec: Specification {","        typealias T = EvaluationContext","    }","","    let provider = MockContextProvider()","        .withFlag(\"enabled\", value: true)","        .withCounter(\"count\", value: 5)","","    let spec = TestSpec()","    let context = provider.currentContext()","","    \/\/ Both conditions satisfied","    XCTAssertTrue(spec.isSatisfiedBy(context))","","    \/\/ Disable flag - should fail","    provider.setFlag(\"enabled\", to: false)","    XCTAssertFalse(spec.isSatisfiedBy(context))","","    \/\/ Exceed count - should fail","    provider.setFlag(\"enabled\", to: true)","    provider.setCounter(\"count\", to: 15)","    XCTAssertFalse(spec.isSatisfiedBy(context))","}","","func testSpecsWithAutoContext() async throws {","    @specs(","        FeatureFlagSpec(flagKey: \"feature_enabled\")","    )","    @AutoContext","    struct AutoSpec: Specification {","        typealias T = EvaluationContext","    }","","    \/\/ Set up test context","    DefaultContextProvider.shared.setFlag(\"feature_enabled\", to: true)","","    let spec = AutoSpec()","","    \/\/ Test using isSatisfied property","    let result = try await spec.isSatisfied","    XCTAssertTrue(result)","}"],"syntax":"swift"},{"anchor":"Best-Practices","type":"heading","text":"Best Practices","level":2},{"anchor":"Use-Descriptive-Specification-Names","type":"heading","text":"Use Descriptive Specification Names","level":3},{"type":"codeListing","code":["\/\/ ✅ Good - clear intent","@specs(","    PremiumUserSpec(),","    EmailVerifiedSpec(),","    NoViolationsSpec()",")","struct PremiumAccessSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ ❌ Avoid - unclear purpose","@specs(","    Spec1(),","    Spec2(),","    Spec3()",")","struct ComboSpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"anchor":"Group-Related-Specifications","type":"heading","text":"Group Related Specifications","level":3},{"type":"codeListing","code":["\/\/ ✅ Good - grouped by concern","@specs(","    \/\/ Account status","    FeatureFlagSpec(flagKey: \"account_active\"),","    FeatureFlagSpec(flagKey: \"email_verified\"),","","    \/\/ Usage limits","    MaxCountSpec.dailyLimit(\"api_calls\", limit: 1000),","    CooldownIntervalSpec.hourly(\"rate_limit\"),","","    \/\/ Security","    MaxCountSpec(counterKey: \"failed_attempts\", maximumCount: 3)",")","struct SecureAPIAccessSpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"anchor":"Document-Complex-Specifications","type":"heading","text":"Document Complex Specifications","level":3},{"type":"codeListing","code":["\/\/\/ Determines eligibility for loyalty rewards program.","\/\/\/","\/\/\/ Requirements:","\/\/\/ - Account registered for at least 30 days","\/\/\/ - Email verified","\/\/\/ - Made at least 5 purchases","\/\/\/ - No account violations","\/\/\/ - Loyalty program is currently active","@specs(","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 30),","    FeatureFlagSpec(flagKey: \"email_verified\"),","    MaxCountSpec(counterKey: \"purchases\", maximumCount: 5).not(),","    MaxCountSpec(counterKey: \"violations\", maximumCount: 0),","    FeatureFlagSpec(flagKey: \"loyalty_program_active\")",")","struct LoyaltyRewardsEligibilitySpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"anchor":"Combine-with-Property-Wrappers","type":"heading","text":"Combine with Property Wrappers","level":3},{"type":"codeListing","code":["@specs(","    PremiumSubscriptionSpec(),","    NoPaymentIssuesSpec(),","    AccountInGoodStandingSpec()",")","struct PremiumAccessSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Use with @Satisfies for clean integration","@Satisfies(using: PremiumAccessSpec())","var hasPremiumAccess: Bool","","if hasPremiumAccess {","    showPremiumContent()","}"],"syntax":"swift"},{"anchor":"Performance-Considerations","type":"heading","text":"Performance Considerations","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Single Evaluation","type":"text"}],"type":"strong"},{"type":"text","text":": Composite specification is created once at initialization"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Chained Evaluation","type":"text"}],"type":"strong"},{"type":"text","text":": Evaluates specifications in order, stops at first failure"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"No Overhead","type":"text"}],"type":"strong"},{"text":": Macro expansion happens at compile time","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Type Erasure"}]},{"type":"text","text":": Uses "},{"code":"AnySpecification","type":"codeVoice"},{"text":" for type erasure (minimal overhead)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Short-Circuit Logic"}]},{"type":"text","text":": AND logic stops at first false result"}]}]}],"type":"unorderedList"},{"level":2,"anchor":"Comparison-with-Manual-Composition","type":"heading","text":"Comparison with Manual Composition"},{"level":3,"text":"Manual Composition","type":"heading","anchor":"Manual-Composition"},{"code":["struct ManualCompositeSpec: Specification {","    typealias T = EvaluationContext","","    private let spec1 = FeatureFlagSpec(flagKey: \"enabled\")","    private let spec2 = MaxCountSpec(counterKey: \"count\", maximumCount: 10)","    private let spec3 = TimeSinceEventSpec(eventKey: \"start\", days: 7)","","    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {","        return spec1.and(spec2).and(spec3).isSatisfiedBy(candidate)","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"With-specs-Macro","type":"heading","level":3,"text":"With @specs Macro"},{"type":"codeListing","code":["@specs(","    FeatureFlagSpec(flagKey: \"enabled\"),","    MaxCountSpec(counterKey: \"count\", maximumCount: 10),","    TimeSinceEventSpec(eventKey: \"start\", days: 7)",")","struct MacroCompositeSpec: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Benefits of @specs","type":"text"}],"type":"strong"},{"text":":","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Less boilerplate (no manual property declarations)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Clearer intent (specifications listed declaratively)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Consistent pattern across codebase","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Automatic validation at compile time"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Less room for implementation errors"}],"type":"paragraph"}]}]}]}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AutoContextMacro":{"type":"topic","kind":"article","abstract":[{"type":"text","text":"A macro that automatically provides context provider conformance and enables convenient async specification evaluation."}],"url":"\/documentation\/specificationcore\/autocontextmacro","title":"@AutoContext Macro","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AutoContextMacro","role":"collectionGroup"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","url":"\/documentation\/specificationcore\/anyspecification","kind":"symbol","abstract":[{"text":"A type-erased wrapper for any specification optimized for performance.","type":"text"},{"type":"text","text":" "},{"text":"This allows you to store specifications of different concrete types in the same collection","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or use them in contexts where the specific type isn’t known at compile time."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnySpecification","kind":"identifier"}],"title":"AnySpecification","type":"topic","role":"symbol","navigatorTitle":[{"text":"AnySpecification","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]}}}