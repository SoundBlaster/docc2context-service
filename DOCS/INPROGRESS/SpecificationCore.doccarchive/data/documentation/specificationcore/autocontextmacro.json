{"topicSections":[{"anchor":"Related-Macros","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro"],"title":"Related Macros"}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"@AutoContext","type":"codeVoice"},{"text":" macro eliminates boilerplate by automatically injecting the necessary code for specifications to work with ","type":"text"},{"isActive":true,"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DefaultContextProvider","type":"reference"},{"type":"text","text":". It adds conformance to "},{"code":"AutoContextSpecification","type":"codeVoice"},{"text":", provides a context provider property, and when combined with ","type":"text"},{"code":"specs","type":"codeVoice"},{"type":"text","text":", adds an "},{"type":"codeVoice","code":"isSatisfied"},{"type":"text","text":" computed property for convenient async evaluation."}]},{"level":3,"text":"Key Benefits","type":"heading","anchor":"Key-Benefits"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Eliminates Boilerplate","type":"text"}]},{"type":"text","text":": No manual context provider wiring needed"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Auto-Conformance"}],"type":"strong"},{"text":": Automatically conforms to ","type":"text"},{"type":"codeVoice","code":"AutoContextSpecification"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Convenience Property"}]},{"text":": Adds ","type":"text"},{"type":"codeVoice","code":"isSatisfied"},{"text":" async property when used with ","type":"text"},{"type":"codeVoice","code":"specs"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Default Provider","type":"text"}]},{"text":": Uses ","type":"text"},{"code":"DefaultContextProvider.shared","type":"codeVoice"},{"text":" automatically","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Type-Safe"}]},{"type":"text","text":": Compile-time type checking for context providers"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Future-Proof","type":"text"}]},{"text":": Designed to support custom providers in future versions","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","text":"When to Use @AutoContext","anchor":"When-to-Use-AutoContext","level":3},{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"type":"codeVoice","code":"@AutoContext"},{"type":"text","text":" when you need to:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Create specifications that work with the default context provider"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Enable convenient async evaluation without explicit provider passing","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Reduce boilerplate in specification definitions"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Build reusable specification types that automatically have provider access"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Combine with ","type":"text"},{"code":"specs","type":"codeVoice"},{"text":" macro for maximum convenience","type":"text"}]}]}]},{"text":"Quick Example","type":"heading","level":2,"anchor":"Quick-Example"},{"code":["import SpecificationCore","","\/\/ Without @AutoContext - manual provider management","struct PremiumUserSpec: Specification {","    typealias T = EvaluationContext","","    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {","        return candidate.flag(for: \"premium_subscription\")","    }","","    \/\/ Manual usage requires provider","    static func evaluate() -> Bool {","        let context = DefaultContextProvider.shared.currentContext()","        return Self().isSatisfiedBy(context)","    }","}","","\/\/ With @AutoContext - automatic provider access","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"premium_subscription\")",")","struct PremiumUserSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Convenient async evaluation","if try await PremiumUserSpec().isSatisfied {","    enablePremiumFeatures()","}"],"type":"codeListing","syntax":"swift"},{"text":"How @AutoContext Works","type":"heading","level":2,"anchor":"How-AutoContext-Works"},{"inlineContent":[{"type":"text","text":"The macro generates provider-related boilerplate automatically:"}],"type":"paragraph"},{"syntax":"swift","code":["@AutoContext","struct MySpec: Specification {","    typealias T = EvaluationContext","    \/\/ Your specification logic...","}","","\/\/ Expands to add:","struct MySpec: Specification {","    typealias T = EvaluationContext","","    \/\/ Generated by @AutoContext:","    public typealias Provider = DefaultContextProvider","    public static var contextProvider: DefaultContextProvider {","        DefaultContextProvider.shared","    }","","    \/\/ Your specification logic...","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"When combined with ","type":"text"},{"code":"specs","type":"codeVoice"},{"text":", it also adds:","type":"text"}]},{"syntax":"swift","code":["@AutoContext","@specs(SomeSpec())","struct MySpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Also generates:","public var isSatisfied: Bool {","    get async throws {","        let ctx = try await Self.contextProvider.currentContextAsync()","        return composite.isSatisfiedBy(ctx)","    }","}"],"type":"codeListing"},{"type":"heading","text":"Usage Examples","level":2,"anchor":"Usage-Examples"},{"type":"heading","text":"Basic Auto-Context Specification","level":3,"anchor":"Basic-Auto-Context-Specification"},{"syntax":"swift","code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"new_feature_enabled\")",")","struct NewFeatureSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Usage with isSatisfied","let spec = NewFeatureSpec()","if try await spec.isSatisfied {","    showNewFeature()","}"],"type":"codeListing"},{"level":3,"text":"Complex Eligibility Specification","type":"heading","anchor":"Complex-Eligibility-Specification"},{"syntax":"swift","code":["@AutoContext","@specs(","    TimeSinceEventSpec(eventKey: \"user_registered\", days: 30),","    FeatureFlagSpec(flagKey: \"email_verified\"),","    MaxCountSpec.dailyLimit(\"premium_actions\", limit: 100),","    CooldownIntervalSpec(eventKey: \"last_violation\", days: 90)",")","struct PremiumEligibilitySpec: Specification {","    typealias T = EvaluationContext","}","","func checkEligibility() async throws -> Bool {","    let spec = PremiumEligibilitySpec()","    return try await spec.isSatisfied","}"],"type":"codeListing"},{"level":3,"text":"Feature Gate with Auto-Context","type":"heading","anchor":"Feature-Gate-with-Auto-Context"},{"type":"codeListing","code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"experimental_ui\"),","    UserSegmentSpec(expectedSegment: .beta)",")","struct ExperimentalUIAccessSpec: Specification {","    typealias T = EvaluationContext","}","","func loadAppInterface() async {","    do {","        if try await ExperimentalUIAccessSpec().isSatisfied {","            loadExperimentalUI()","        } else {","            loadStandardUI()","        }","    } catch {","        \/\/ Handle error - fall back to standard UI","        loadStandardUI()","    }","}"],"syntax":"swift"},{"type":"heading","text":"API Access Control","anchor":"API-Access-Control","level":3},{"type":"codeListing","code":["@AutoContext","@specs(","    MaxCountSpec.dailyLimit(\"api_calls\", limit: 10000),","    MaxCountSpec(counterKey: \"hourly_calls\", maximumCount: 1000),","    FeatureFlagSpec(flagKey: \"api_enabled\"),","    CooldownIntervalSpec(eventKey: \"rate_limit_violation\", minutes: 5)",")","struct APIAccessSpec: Specification {","    typealias T = EvaluationContext","}","","func canMakeAPICall() async throws -> Bool {","    return try await APIAccessSpec().isSatisfied","}","","func performAPICall() async throws {","    guard try await canMakeAPICall() else {","        throw APIError.rateLimitExceeded","    }","","    \/\/ Make API call","    let response = try await apiClient.request()","","    \/\/ Track usage","    DefaultContextProvider.shared.incrementCounter(\"api_calls\")","    DefaultContextProvider.shared.incrementCounter(\"hourly_calls\")","","    return response","}"],"syntax":"swift"},{"type":"heading","text":"Real-World Examples","anchor":"Real-World-Examples","level":2},{"type":"heading","text":"Subscription Access Manager","anchor":"Subscription-Access-Manager","level":3},{"type":"codeListing","code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"subscription_active\"),","    DateComparisonSpec(","        eventKey: \"subscription_start\",","        comparison: .before,","        date: Date()","    ),","    MaxCountSpec(counterKey: \"payment_failures\", maximumCount: 0)",")","struct ActiveSubscriptionSpec: Specification {","    typealias T = EvaluationContext","}","","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"subscription_cancelled\").not(),","    DateComparisonSpec(","        eventKey: \"subscription_end\",","        comparison: .after,","        date: Date()","    )",")","struct ValidSubscriptionPeriodSpec: Specification {","    typealias T = EvaluationContext","}","","class SubscriptionManager {","    func checkAccess() async throws -> AccessLevel {","        let isActive = try await ActiveSubscriptionSpec().isSatisfied","        let isValid = try await ValidSubscriptionPeriodSpec().isSatisfied","","        if isActive && isValid {","            return .full","        } else if isValid {","            return .gracePeriod","        } else {","            return .none","        }","    }","}"],"syntax":"swift"},{"type":"heading","text":"Content Moderation System","anchor":"Content-Moderation-System","level":3},{"type":"codeListing","code":["@AutoContext","@specs(","    MaxCountSpec(counterKey: \"content_warnings\", maximumCount: 3),","    MaxCountSpec(counterKey: \"community_reports\", maximumCount: 10),","    TimeSinceEventSpec(eventKey: \"last_suspension\", days: 90),","    FeatureFlagSpec(flagKey: \"account_suspended\").not()",")","struct CanPostContentSpec: Specification {","    typealias T = EvaluationContext","}","","@AutoContext","@specs(","    MaxCountSpec(counterKey: \"moderation_flags\", maximumCount: 1),","    CooldownIntervalSpec(eventKey: \"last_flagged_post\", hours: 24),","    FeatureFlagSpec(flagKey: \"auto_moderation_enabled\").not()",")","struct RequiresModerationSpec: Specification {","    typealias T = EvaluationContext","}","","class ContentManager {","    func submitPost(_ content: String) async throws {","        let canPost = try await CanPostContentSpec().isSatisfied","","        guard canPost else {","            throw ContentError.postingRestricted","        }","","        let needsModeration = try await RequiresModerationSpec().isSatisfied","","        if needsModeration {","            await queueForModeration(content)","        } else {","            await publishImmediately(content)","        }","    }","}"],"syntax":"swift"},{"type":"heading","text":"Feature Rollout Controller","anchor":"Feature-Rollout-Controller","level":3},{"code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"feature_enabled\"),","    DateRangeSpec(start: rolloutStart, end: rolloutEnd),","    UserSegmentSpec(expectedSegment: .beta)",")","struct BetaFeatureSpec: Specification {","    typealias T = EvaluationContext","}","","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"feature_enabled\"),","    DateComparisonSpec(eventKey: \"general_availability_date\", comparison: .after, date: Date())",")","struct GAFeatureSpec: Specification {","    typealias T = EvaluationContext","}","","class FeatureRolloutManager {","    func determineFeatureAvailability() async throws -> FeatureAvailability {","        let isBetaUser = try await BetaFeatureSpec().isSatisfied","        let isGA = try await GAFeatureSpec().isSatisfied","","        if isGA {","            return .generallyAvailable","        } else if isBetaUser {","            return .betaAccess","        } else {","            return .unavailable","        }","    }","","    func enableFeatureIfAvailable() async {","        do {","            let availability = try await determineFeatureAvailability()","","            switch availability {","            case .generallyAvailable:","                enableFeature(withBadge: nil)","            case .betaAccess:","                enableFeature(withBadge: \"BETA\")","            case .unavailable:","                showComingSoonMessage()","            }","        } catch {","            logError(\"Feature availability check failed: \\(error)\")","            showComingSoonMessage()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Multi-Tier-Access-Control","text":"Multi-Tier Access Control","type":"heading","level":3},{"code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"free_tier\")",")","struct FreeTierSpec: Specification {","    typealias T = EvaluationContext","}","","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"premium_subscription\"),","    MaxCountSpec(counterKey: \"premium_features_used\", maximumCount: 100)",")","struct PremiumTierSpec: Specification {","    typealias T = EvaluationContext","}","","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"enterprise_subscription\"),","    FeatureFlagSpec(flagKey: \"dedicated_support\")",")","struct EnterpriseTierSpec: Specification {","    typealias T = EvaluationContext","}","","class TierManager {","    func getCurrentTier() async throws -> UserTier {","        if try await EnterpriseTierSpec().isSatisfied {","            return .enterprise","        } else if try await PremiumTierSpec().isSatisfied {","            return .premium","        } else if try await FreeTierSpec().isSatisfied {","            return .free","        } else {","            return .none","        }","    }","","    func getFeatureAccess() async throws -> [Feature] {","        let tier = try await getCurrentTier()","","        switch tier {","        case .enterprise:","            return Feature.allCases","        case .premium:","            return Feature.premiumFeatures","        case .free:","            return Feature.freeFeatures","        case .none:","            return []","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Combining-with-Property-Wrappers","text":"Combining with Property Wrappers","type":"heading","level":2},{"inlineContent":[{"text":"Use @AutoContext specifications with property wrappers for clean integration:","type":"text"}],"type":"paragraph"},{"code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"new_ui_enabled\")",")","struct NewUISpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Use with @Satisfies","@Satisfies(using: NewUISpec())","var shouldShowNewUI: Bool","","\/\/ Or evaluate directly","func checkNewUI() async throws -> Bool {","    return try await NewUISpec().isSatisfied","}"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"SwiftUI-Integration","type":"heading","text":"SwiftUI Integration"},{"inlineContent":[{"text":"Use @AutoContext specifications in SwiftUI views:","type":"text"}],"type":"paragraph"},{"code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"premium_features\"),","    TimeSinceEventSpec(eventKey: \"subscription_start\", days: 0)",")","struct PremiumAccessSpec: Specification {","    typealias T = EvaluationContext","}","","struct ContentView: View {","    @State private var hasPremiumAccess = false","    @State private var isLoading = true","","    var body: some View {","        Group {","            if isLoading {","                ProgressView(\"Checking access...\")","            } else if hasPremiumAccess {","                PremiumContentView()","            } else {","                FreeContentView()","            }","        }","        .task {","            await checkAccess()","        }","    }","","    func checkAccess() async {","        isLoading = true","        defer { isLoading = false }","","        do {","            hasPremiumAccess = try await PremiumAccessSpec().isSatisfied","        } catch {","            hasPremiumAccess = false","            print(\"Access check failed: \\(error)\")","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Error Handling","level":2,"anchor":"Error-Handling"},{"type":"paragraph","inlineContent":[{"text":"Handle errors from async specification evaluation:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"feature_enabled\")",")","struct FeatureSpec: Specification {","    typealias T = EvaluationContext","}","","func checkFeature() async {","    do {","        let isEnabled = try await FeatureSpec().isSatisfied","","        if isEnabled {","            enableFeature()","        } else {","            disableFeature()","        }","    } catch {","        \/\/ Handle error - use safe default","        disableFeature()","        logError(\"Feature check failed: \\(error)\")","    }","}"]},{"type":"heading","text":"Testing","level":2,"anchor":"Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test @AutoContext specifications using the standard provider:"}]},{"type":"codeListing","syntax":"swift","code":["func testAutoContextSpec() async throws {","    @AutoContext","    @specs(","        FeatureFlagSpec(flagKey: \"test_feature\")","    )","    struct TestSpec: Specification {","        typealias T = EvaluationContext","    }","","    \/\/ Set up test state","    DefaultContextProvider.shared.setFlag(\"test_feature\", to: true)","","    \/\/ Test using isSatisfied","    let spec = TestSpec()","    let result = try await spec.isSatisfied","","    XCTAssertTrue(result)","","    \/\/ Test with flag disabled","    DefaultContextProvider.shared.setFlag(\"test_feature\", to: false)","    let result2 = try await spec.isSatisfied","","    XCTAssertFalse(result2)","}"]},{"type":"heading","text":"Future Enhancements","level":2,"anchor":"Future-Enhancements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The @AutoContext macro is designed to support future features:"}]},{"type":"heading","text":"Custom Provider Types (Planned)","level":3,"anchor":"Custom-Provider-Types-Planned"},{"type":"codeListing","syntax":"swift","code":["\/\/ Future: Custom provider type","@AutoContext(CustomProvider.self)","struct MySpec: Specification {","    typealias T = CustomContext","}"]},{"text":"SwiftUI Environment Integration (Planned)","type":"heading","level":3,"anchor":"SwiftUI-Environment-Integration-Planned"},{"syntax":"swift","type":"codeListing","code":["\/\/ Future: Environment-based provider","@AutoContext(environment)","struct MySpec: Specification {","    typealias T = EvaluationContext","}"]},{"text":"Provider Inference (Planned)","type":"heading","level":3,"anchor":"Provider-Inference-Planned"},{"syntax":"swift","type":"codeListing","code":["\/\/ Future: Infer provider from context type","@AutoContext(infer)","struct MySpec: Specification {","    typealias T = CustomContext","}"]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Note"}],"type":"strong"},{"type":"text","text":": These features emit informative warnings when used, indicating they are recognized but not yet implemented."}],"type":"paragraph"},{"type":"heading","level":2,"text":"Best Practices","anchor":"Best-Practices"},{"type":"heading","level":3,"text":"Always Use with @specs","anchor":"Always-Use-with-specs"},{"type":"codeListing","code":["\/\/ ✅ Good - combined with @specs","@AutoContext","@specs(","    FeatureFlagSpec(flagKey: \"enabled\")",")","struct MySpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ ❌ Less useful - @AutoContext alone doesn't add much value","@AutoContext","struct MySpec: Specification {","    typealias T = EvaluationContext","","    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {","        \/\/ Manual implementation","        return candidate.flag(for: \"enabled\")","    }","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"Handle Async Errors Appropriately","anchor":"Handle-Async-Errors-Appropriately"},{"type":"codeListing","code":["\/\/ ✅ Good - proper error handling","func checkAccess() async -> Bool {","    do {","        return try await AccessSpec().isSatisfied","    } catch {","        logError(error)","        return false  \/\/ Safe default","    }","}","","\/\/ ❌ Avoid - ignoring errors","func checkAccess() async -> Bool {","    return (try? await AccessSpec().isSatisfied) ?? false","    \/\/ Lost error information","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"Use Descriptive Specification Names","anchor":"Use-Descriptive-Specification-Names"},{"type":"codeListing","code":["\/\/ ✅ Good - clear purpose","@AutoContext","@specs(...)","struct PremiumContentAccessSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ ❌ Avoid - unclear naming","@AutoContext","@specs(...)","struct Spec1: Specification {","    typealias T = EvaluationContext","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Performance Considerations","anchor":"Performance-Considerations"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Shared Provider"}]},{"type":"text","text":": Uses singleton "},{"type":"codeVoice","code":"DefaultContextProvider.shared"},{"type":"text","text":" (no allocation overhead)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Async Evaluation"}]},{"text":": ","type":"text"},{"type":"codeVoice","code":"isSatisfied"},{"text":" property uses async context fetching","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Compile-Time","type":"text"}]},{"text":": Macro expansion happens at compile time (no runtime overhead)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Type Erasure","type":"text"}],"type":"strong"},{"text":": Minimal overhead from ","type":"text"},{"type":"codeVoice","code":"AnySpecification"},{"text":" usage","type":"text"}]}]}],"type":"unorderedList"},{"type":"heading","text":"Comparison with Manual Provider Management","level":2,"anchor":"Comparison-with-Manual-Provider-Management"},{"type":"heading","text":"Manual Provider Management","level":3,"anchor":"Manual-Provider-Management"},{"type":"codeListing","syntax":"swift","code":["struct ManualSpec: Specification {","    typealias T = EvaluationContext","","    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {","        \/\/ Implementation...","        return true","    }","","    \/\/ Manual evaluation helper","    static func evaluate() -> Bool {","        let context = DefaultContextProvider.shared.currentContext()","        return Self().isSatisfiedBy(context)","    }","}","","\/\/ Usage","if ManualSpec.evaluate() {","    \/\/ Do something","}"]},{"type":"heading","text":"With @AutoContext Macro","level":3,"anchor":"With-AutoContext-Macro"},{"type":"codeListing","syntax":"swift","code":["@AutoContext","@specs(...)","struct AutoSpec: Specification {","    typealias T = EvaluationContext","}","","\/\/ Usage - cleaner async API","if try await AutoSpec().isSatisfied {","    \/\/ Do something","}"]}]}],"kind":"article","sections":[],"seeAlsoSections":[{"anchor":"Related-Documentation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DefaultContextProvider","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"title":"Related Documentation"},{"generated":true,"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro"],"anchor":"Macros","title":"Macros"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/specificationcore\/autocontextmacro"]}],"abstract":[{"type":"text","text":"A macro that automatically provides context provider conformance and enables convenient async specification evaluation."}],"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AutoContextMacro"},"metadata":{"title":"@AutoContext Macro","role":"collectionGroup","modules":[{"name":"SpecificationCore"}]},"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"],["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro"]]},"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DefaultContextProvider":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DefaultContextProvider","kind":"symbol","type":"topic","abstract":[{"text":"A thread-safe context provider that maintains application-wide state for specification evaluation.","type":"text"}],"title":"DefaultContextProvider","navigatorTitle":[{"text":"DefaultContextProvider","kind":"identifier"}],"url":"\/documentation\/specificationcore\/defaultcontextprovider","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"DefaultContextProvider","kind":"identifier"}],"role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/SpecsMacro":{"kind":"article","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecsMacro","type":"topic","abstract":[{"text":"A macro that generates composite specifications by combining multiple specification instances with AND logic.","type":"text"}],"title":"@specs Macro","url":"\/documentation\/specificationcore\/specsmacro","role":"collectionGroup"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"}}}