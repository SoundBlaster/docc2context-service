{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/specificationcore\/anyspecification"]}],"kind":"symbol","sections":[],"metadata":{"symbolKind":"struct","navigatorTitle":[{"text":"AnySpecification","kind":"identifier"}],"roleHeading":"Structure","title":"AnySpecification","modules":[{"name":"SpecificationCore"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnySpecification","kind":"identifier"}],"role":"symbol","externalID":"s:17SpecificationCore03AnyA0V"},"seeAlsoSections":[{"anchor":"Related-Documentation","title":"Related Documentation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyDecisionSpec"]},{"anchor":"Core-Protocols","title":"Core Protocols","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DecisionSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyContextProvider"],"generated":true}],"abstract":[{"text":"A type-erased wrapper for any specification optimized for performance.","type":"text"},{"text":" ","type":"text"},{"text":"This allows you to store specifications of different concrete types in the same collection","type":"text"},{"text":" ","type":"text"},{"text":"or use them in contexts where the specific type isn’t known at compile time.","type":"text"}],"identifier":{"url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"topicSections":[{"anchor":"Evaluating-Specifications","title":"Evaluating Specifications","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/isSatisfiedBy(_:)"]},{"anchor":"Constant-Specifications","title":"Constant Specifications","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/always","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/never","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/constantTrue()","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/constantFalse()"]},{"anchor":"Helper-Types","title":"Helper Types","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AlwaysTrueSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AlwaysFalseSpec"]},{"anchor":"Initializers","title":"Initializers","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/init(_:)-2x209","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/init(_:)-5c190"],"generated":true},{"anchor":"Default-Implementations","title":"Default Implementations","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/Specification-Implementations"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"relationshipsSections":[{"title":"Conforms To","type":"conformsTo","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification"],"kind":"relationships"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"languages":["swift"],"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnySpecification","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"text":">","kind":"text"}],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"Performance-Optimizations","text":"Performance Optimizations","level":2,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"@inlinable methods","type":"text"}],"type":"strong"},{"text":": Enable compiler optimization across module boundaries","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Specialized storage","type":"text"}]},{"type":"text","text":": Different storage strategies based on specification type"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Copy-on-write semantics"}],"type":"strong"},{"text":": Minimize memory allocations","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Thread-safe design"}],"type":"strong"},{"type":"text","text":": No internal state requiring synchronization"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"A type-erased wrapper for specifications with performance optimizations.","type":"text"}]},{"level":2,"anchor":"Overview","text":"Overview","type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"AnySpecification"},{"type":"text","text":" is a type-erased wrapper that allows you to store specifications of different concrete types in the same collection or use them in contexts where the specific type isn’t known at compile time. It’s optimized for performance with specialized storage strategies and compiler optimizations."}],"type":"paragraph"},{"level":3,"anchor":"Key-Benefits","text":"Key Benefits","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Type Erasure"}]},{"type":"text","text":": Store different specification types together"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Performance Optimized","type":"text"}],"type":"strong"},{"text":": Specialized storage and inlinable methods","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Flexible Creation"}]},{"text":": Create from specifications or closures","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Constant Optimization","type":"text"}]},{"type":"text","text":": Special handling for always-true\/always-false specs"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Collection Utilities","type":"text"}]},{"text":": Combine multiple specifications easily","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"text":"When to Use AnySpecification","anchor":"When-to-Use-AnySpecification","type":"heading"},{"inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"AnySpecification"},{"type":"text","text":" when you need to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Store specifications in collections or arrays","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Return specifications from functions with different concrete types"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Create specifications dynamically at runtime","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Build flexible specification factories"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Work with specifications through protocols","type":"text"}]}]}],"type":"unorderedList"},{"level":2,"text":"Quick Example","anchor":"Quick-Example","type":"heading"},{"code":["import SpecificationCore","","struct User {","    let age: Int","    let isActive: Bool","}","","\/\/ Create from a concrete specification","struct AdultSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.age >= 18","    }","}","","let anySpec = AnySpecification(AdultSpec())","let isAdult = anySpec.isSatisfiedBy(user)","","\/\/ Create from a closure","let activeSpec = AnySpecification<User> { user in","    user.isActive","}","","let isActive = activeSpec.isSatisfiedBy(user)"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Storing Specifications in Collections","anchor":"Storing-Specifications-in-Collections","type":"heading"},{"inlineContent":[{"type":"text","text":"Type erasure allows heterogeneous specification collections:"}],"type":"paragraph"},{"code":["struct AdultSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.age >= 18","    }","}","","struct ActiveSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.isActive","    }","}","","\/\/ Store different specification types together","let rules: [AnySpecification<User>] = [","    AnySpecification(AdultSpec()),","    AnySpecification(ActiveSpec()),","    AnySpecification { user in user.age < 65 },","    AnySpecification { user in user.email.contains(\"@\") }","]","","\/\/ Evaluate all rules","let passesAll = rules.allSatisfy { spec in","    spec.isSatisfiedBy(user)","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Creating-from-Closures","type":"heading","text":"Creating from Closures","level":2},{"inlineContent":[{"text":"Create specifications directly from predicates:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Simple closure-based specification","let emailValid = AnySpecification<User> { user in","    user.email.contains(\"@\") && user.email.contains(\".\")","}","","\/\/ Complex closure with multiple conditions","let eligibleUser = AnySpecification<User> { user in","    user.age >= 18 &&","    user.isActive &&","    user.emailVerified &&","    !user.isBanned","}","","\/\/ Use like any other specification","if eligibleUser.isSatisfiedBy(user) {","    print(\"User is eligible\")","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Constant-Specifications","type":"heading","text":"Constant Specifications","level":2},{"inlineContent":[{"type":"text","text":"Use optimized constant specifications for always-true or always-false cases:"}],"type":"paragraph"},{"code":["\/\/ Always-true specification","let alwaysTrue = AnySpecification<User>.always","","\/\/ Always-false specification","let alwaysFalse = AnySpecification<User>.never","","\/\/ Optimized constant functions","let trueSpec = AnySpecification<User>.constantTrue()","let falseSpec = AnySpecification<User>.constantFalse()","","\/\/ Use in conditional logic","let spec = featureEnabled","    ? AnySpecification(FeatureSpec())","    : AnySpecification<User>.never"],"type":"codeListing","syntax":"swift"},{"anchor":"Collection-Extensions","type":"heading","text":"Collection Extensions","level":2},{"inlineContent":[{"text":"Combine multiple specifications from collections:","type":"text"}],"type":"paragraph"},{"anchor":"All-Satisfied-AND","type":"heading","text":"All Satisfied (AND)","level":3},{"inlineContent":[{"text":"Create a specification that requires all specs to be satisfied:","type":"text"}],"type":"paragraph"},{"code":["let validationRules = [","    AnySpecification(EmailValidSpec()),","    AnySpecification(PasswordStrongSpec()),","    AnySpecification(AgeRequirementSpec())","]","","\/\/ All validations must pass","let allValid = validationRules.allSatisfied()","","if allValid.isSatisfiedBy(user) {","    print(\"All validations passed\")","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Any-Satisfied-OR","type":"heading","text":"Any Satisfied (OR)","level":3},{"inlineContent":[{"text":"Create a specification satisfied when any spec matches:","type":"text"}],"type":"paragraph"},{"code":["let discountEligibility = [","    AnySpecification(PremiumMemberSpec()),","    AnySpecification(FirstTimeBuyerSpec()),","    AnySpecification(HolidayPromoSpec())","]","","\/\/ Any condition grants discount","let getsDiscount = discountEligibility.anySatisfied()","","if getsDiscount.isSatisfiedBy(user) {","    print(\"Discount applied\")","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Dynamic-Specification-Factory","type":"heading","text":"Dynamic Specification Factory","level":2},{"inlineContent":[{"text":"Build specifications dynamically based on configuration:","type":"text"}],"type":"paragraph"},{"code":["struct SpecificationFactory {","    static func create(for rules: [String: Any]) -> AnySpecification<User> {","        var specs: [AnySpecification<User>] = []","","        if let minAge = rules[\"minAge\"] as? Int {","            specs.append(AnySpecification { user in user.age >= minAge })","        }","","        if let requiredRole = rules[\"role\"] as? String {","            specs.append(AnySpecification { user in user.role == requiredRole })","        }","","        if let mustBeActive = rules[\"active\"] as? Bool, mustBeActive {","            specs.append(AnySpecification { user in user.isActive })","        }","","        \/\/ Combine all specs with AND logic","        return specs.isEmpty","            ? .always","            : specs.allSatisfied()","    }","}","","\/\/ Use factory","let config = [\"minAge\": 18, \"active\": true, \"role\": \"member\"]","let spec = SpecificationFactory.create(for: config)","let passes = spec.isSatisfiedBy(user)"],"type":"codeListing","syntax":"swift"},{"anchor":"Wrapping-Complex-Specifications","type":"heading","text":"Wrapping Complex Specifications","level":2},{"inlineContent":[{"type":"text","text":"Simplify complex specification hierarchies:"}],"type":"paragraph"},{"code":["\/\/ Complex nested specification","let complexSpec = AdultSpec()","    .and(ActiveSpec())","    .or(PremiumSpec())","    .and(VerifiedSpec().not())","","\/\/ Wrap in AnySpecification for simpler type","let wrapped = AnySpecification(complexSpec)","","\/\/ Can now be stored, returned, or passed around easily","func getEligibilitySpec() -> AnySpecification<User> {","    wrapped  \/\/ Simpler return type","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Helper-Specification-Types","type":"heading","text":"Helper Specification Types","level":2},{"inlineContent":[{"type":"codeVoice","code":"AnySpecification"},{"type":"text","text":" provides helper types for constants:"}],"type":"paragraph"},{"anchor":"AlwaysTrueSpec","type":"heading","text":"AlwaysTrueSpec","level":3},{"type":"codeListing","syntax":"swift","code":["let alwaysTrue = AlwaysTrueSpec<User>()","alwaysTrue.isSatisfiedBy(anyUser)  \/\/ Always returns true","","\/\/ Wrapped automatically","let wrapped = AnySpecification(AlwaysTrueSpec<User>())","\/\/ Uses optimized .constantTrue storage"]},{"level":3,"anchor":"AlwaysFalseSpec","text":"AlwaysFalseSpec","type":"heading"},{"type":"codeListing","syntax":"swift","code":["let alwaysFalse = AlwaysFalseSpec<User>()","alwaysFalse.isSatisfiedBy(anyUser)  \/\/ Always returns false","","\/\/ Wrapped automatically","let wrapped = AnySpecification(AlwaysFalseSpec<User>())","\/\/ Uses optimized .constantFalse storage"]},{"text":"Composition with Type Erasure","anchor":"Composition-with-Type-Erasure","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Combine type-erased specifications using composition operators:"}]},{"type":"codeListing","code":["let spec1 = AnySpecification<User> { $0.age >= 18 }","let spec2 = AnySpecification<User> { $0.isActive }","","\/\/ Compose with operators","let combined = spec1.and(spec2)  \/\/ Returns AndSpecification","","\/\/ Wrap result back in AnySpecification","let erased = AnySpecification(combined)","","\/\/ Or chain directly","let chained = AnySpecification<User> { $0.age >= 18 }","    .and(AnySpecification { $0.isActive })","    .or(AnySpecification { $0.isPremium })"],"syntax":"swift"},{"text":"Convenience Function","anchor":"Convenience-Function","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the global "},{"type":"codeVoice","code":"spec()"},{"type":"text","text":" function for concise creation:"}]},{"type":"codeListing","code":["\/\/ Instead of:","let verbose = AnySpecification<User> { user in user.isActive }","","\/\/ Use:","let concise = spec<User> { $0.isActive }","","\/\/ Compose easily","let combined = spec<User> { $0.age >= 18 }","    .and(spec { $0.isActive })"],"syntax":"swift"},{"text":"Performance Optimizations","anchor":"Performance-Optimizations","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AnySpecification"},{"text":" includes several performance optimizations:","type":"text"}]},{"text":"Inlinable Methods","anchor":"Inlinable-Methods","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"All critical methods are marked "},{"type":"codeVoice","code":"@inlinable"},{"type":"text","text":" for cross-module optimization:"}]},{"type":"codeListing","code":["\/\/ These methods can be inlined by the compiler","public func isSatisfiedBy(_ candidate: T) -> Bool { ... }","public init<S: Specification>(_ specification: S) where S.T == T { ... }"],"syntax":"swift"},{"text":"Specialized Storage","anchor":"Specialized-Storage","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Different storage strategies based on specification type:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".constantTrue"},{"type":"text","text":" - Optimized for always-true specs"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".constantFalse"},{"type":"text","text":" - Optimized for always-false specs"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":".predicate","type":"codeVoice"},{"type":"text","text":" - Direct closure storage"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":".specification","type":"codeVoice"},{"text":" - Wrapped specification","type":"text"}]}]}]},{"anchor":"Optimized-Collection-Methods","type":"heading","text":"Optimized Collection Methods","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Collection extensions optimize for common cases:"}]},{"type":"codeListing","syntax":"swift","code":["let specs = [spec1, spec2, spec3]","","\/\/ Optimizes for empty collections and single elements","let all = specs.allSatisfied()","","\/\/ Returns .constantTrue() for empty","\/\/ Returns wrapped first element for single item","\/\/ Returns combined spec for multiple items"]},{"anchor":"Best-Practices","type":"heading","text":"Best Practices","level":2},{"anchor":"Use-for-Heterogeneous-Collections","type":"heading","text":"Use for Heterogeneous Collections","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - store different spec types","let rules: [AnySpecification<User>] = [","    AnySpecification(ConcreteSpec1()),","    AnySpecification(ConcreteSpec2()),","    AnySpecification { \/* closure *\/ }","]","","\/\/ ❌ Avoid - lose type information unnecessarily","let spec: AnySpecification<User> = AnySpecification(ConcreteSpec())","\/\/ Better to keep ConcreteSpec type if not storing in collection"]},{"anchor":"Prefer-Concrete-Types-When-Possible","type":"heading","text":"Prefer Concrete Types When Possible","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - use concrete type","func createSpec() -> AdultSpec {","    AdultSpec(minimumAge: 18)","}","","\/\/ ❌ Avoid - unnecessary type erasure","func createSpec() -> AnySpecification<User> {","    AnySpecification(AdultSpec(minimumAge: 18))","}"]},{"anchor":"Use-Constant-Specs-Appropriately","type":"heading","text":"Use Constant Specs Appropriately","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - use constants for always-true\/false","let spec = isFeatureEnabled","    ? AnySpecification(FeatureSpec())","    : .never","","\/\/ ❌ Avoid - creating unnecessary closures","let spec = isFeatureEnabled","    ? AnySpecification(FeatureSpec())","    : AnySpecification { _ in false }"]},{"anchor":"Common-Patterns","type":"heading","text":"Common Patterns","level":2},{"anchor":"Guard-Pattern","type":"heading","text":"Guard Pattern","level":3},{"type":"codeListing","syntax":"swift","code":["func validateUser(_ user: User) -> Bool {","    let validations: [AnySpecification<User>] = [","        spec { $0.email.contains(\"@\") },","        spec { $0.age >= 18 },","        spec { $0.isActive }","    ]","","    return validations.allSatisfied().isSatisfiedBy(user)","}"]},{"anchor":"Factory-Pattern","type":"heading","text":"Factory Pattern","level":3},{"type":"codeListing","syntax":"swift","code":["enum UserType {","    case admin, moderator, user","","    var spec: AnySpecification<User> {","        switch self {","        case .admin:","            return spec { $0.role == \"admin\" }","        case .moderator:","            return spec { $0.role == \"moderator\" || $0.role == \"admin\" }","        case .user:","            return .always","        }","    }","}"]},{"anchor":"Builder-Pattern","type":"heading","text":"Builder Pattern","level":3},{"type":"codeListing","syntax":"swift","code":["struct SpecBuilder<T> {","    private var specs: [AnySpecification<T>] = []","","    mutating func add(_ spec: AnySpecification<T>) {","        specs.append(spec)","    }","","    func build() -> AnySpecification<T> {","        specs.allSatisfied()","    }","}","","var builder = SpecBuilder<User>()","builder.add(spec { $0.age >= 18 })","builder.add(spec { $0.isActive })","let combined = builder.build()"]}]}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","url":"\/documentation\/specificationcore\/anyspecification","kind":"symbol","abstract":[{"text":"A type-erased wrapper for any specification optimized for performance.","type":"text"},{"type":"text","text":" "},{"text":"This allows you to store specifications of different concrete types in the same collection","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or use them in contexts where the specific type isn’t known at compile time."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnySpecification","kind":"identifier"}],"title":"AnySpecification","type":"topic","role":"symbol","navigatorTitle":[{"text":"AnySpecification","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DecisionSpec":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DecisionSpec","kind":"identifier"}],"type":"topic","kind":"symbol","abstract":[{"text":"A protocol for specifications that can return a typed result instead of just a boolean.","type":"text"},{"text":" ","type":"text"},{"text":"This extends the specification pattern to support decision-making with payload results.","type":"text"}],"url":"\/documentation\/specificationcore\/decisionspec","title":"DecisionSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DecisionSpec","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DecisionSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnyContextProvider":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"AnyContextProvider","kind":"identifier"}],"type":"topic","kind":"symbol","abstract":[{"text":"A type-erased context provider.","type":"text"}],"url":"\/documentation\/specificationcore\/anycontextprovider","title":"AnyContextProvider","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyContextProvider","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AnyContextProvider"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AlwaysFalseSpec":{"url":"\/documentation\/specificationcore\/alwaysfalsespec","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AlwaysFalseSpec","role":"symbol","title":"AlwaysFalseSpec","abstract":[{"type":"text","text":"A specification that always evaluates to false"}],"navigatorTitle":[{"text":"AlwaysFalseSpec","kind":"identifier"}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AlwaysFalseSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/constantFalse()":{"kind":"symbol","title":"constantFalse()","type":"topic","abstract":[{"text":"Creates an optimized constant false specification","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/constantFalse()","role":"symbol","url":"\/documentation\/specificationcore\/anyspecification\/constantfalse()","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"constantFalse"},{"text":"() -> ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore03AnyA0V","text":"AnySpecification","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnyAsyncSpecification":{"type":"topic","navigatorTitle":[{"text":"AnyAsyncSpecification","kind":"identifier"}],"title":"AnyAsyncSpecification","url":"\/documentation\/specificationcore\/anyasyncspecification","kind":"symbol","abstract":[{"type":"text","text":"A type-erased wrapper for any asynchronous specification."}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyAsyncSpecification","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/init(_:)-2x209":{"title":"init(_:)","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Creates a type-erased specification from a closure."}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/init(_:)-2x209","role":"symbol","url":"\/documentation\/specificationcore\/anyspecification\/init(_:)-2x209","fragments":[{"text":"init","kind":"identifier"},{"text":"((","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp","text":"T","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"},{"text":")","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AlwaysTrueSpec":{"abstract":[{"type":"text","text":"A specification that always evaluates to true"}],"url":"\/documentation\/specificationcore\/alwaystruespec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AlwaysTrueSpec","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AlwaysTrueSpec"}],"title":"AlwaysTrueSpec","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AlwaysTrueSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/ContextProviding":{"role":"symbol","title":"ContextProviding","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding","url":"\/documentation\/specificationcore\/contextproviding","kind":"symbol","navigatorTitle":[{"text":"ContextProviding","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A protocol for types that can provide context for specification evaluation."},{"type":"text","text":" "},{"type":"text","text":"This enables dependency injection and testing by abstracting context creation."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContextProviding","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/always":{"title":"always","kind":"symbol","type":"topic","abstract":[{"text":"Creates a specification that always returns true","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/always","role":"symbol","url":"\/documentation\/specificationcore\/anyspecification\/always","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"always","kind":"identifier"},{"kind":"text","text":": "},{"text":"AnySpecification","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnyDecisionSpec":{"role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyDecisionSpec","kind":"identifier"}],"title":"AnyDecisionSpec","abstract":[{"text":"A type-erased DecisionSpec that can wrap any concrete DecisionSpec implementation","type":"text"}],"url":"\/documentation\/specificationcore\/anydecisionspec","type":"topic","navigatorTitle":[{"text":"AnyDecisionSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyDecisionSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSpecification":{"abstract":[{"text":"A protocol for specifications that require asynchronous evaluation.","type":"text"}],"url":"\/documentation\/specificationcore\/asyncspecification","kind":"symbol","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSpecification"}],"title":"AsyncSpecification","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AsyncSpecification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/constantTrue()":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/constantTrue()","url":"\/documentation\/specificationcore\/anyspecification\/constanttrue()","abstract":[{"type":"text","text":"Creates an optimized constant true specification"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"constantTrue","kind":"identifier"},{"text":"() -> ","kind":"text"},{"text":"AnySpecification","preciseIdentifier":"s:17SpecificationCore03AnyA0V","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"T","preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp","kind":"typeIdentifier"},{"text":">","kind":"text"}],"title":"constantTrue()","type":"topic","role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/isSatisfiedBy(_:)":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/anyspecification\/issatisfiedby(_:)","title":"isSatisfiedBy(_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/isSatisfiedBy(_:)","abstract":[{"type":"text","text":"Evaluates whether the given context satisfies this specification."}],"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"isSatisfiedBy","kind":"identifier"},{"text":"(","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp"},{"text":") -> ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/init(_:)-5c190":{"type":"topic","title":"init(_:)","url":"\/documentation\/specificationcore\/anyspecification\/init(_:)-5c190","kind":"symbol","abstract":[{"text":"Creates a type-erased specification wrapping the given specification.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/init(_:)-5c190","role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"<","kind":"text"},{"text":"S","kind":"genericParameter"},{"text":">(","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore03AnyA0VyACyxGqd__c1TQyd__RszAA0A0Rd__lufc1SL_qd__mfp","text":"S","kind":"typeIdentifier"},{"text":")","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/Specification-Implementations":{"role":"collectionGroup","kind":"article","abstract":[],"type":"topic","url":"\/documentation\/specificationcore\/anyspecification\/specification-implementations","title":"Specification Implementations","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/Specification-Implementations"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification/never":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification\/never","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Creates a specification that always returns false"}],"title":"never","url":"\/documentation\/specificationcore\/anyspecification\/never","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"never"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"AnySpecification","preciseIdentifier":"s:17SpecificationCore03AnyA0V"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T","preciseIdentifier":"s:17SpecificationCore03AnyA0V1Txmfp"},{"kind":"text","text":">"}],"role":"symbol"}}}