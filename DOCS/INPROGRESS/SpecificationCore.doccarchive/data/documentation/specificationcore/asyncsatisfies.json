{"schemaVersion":{"minor":3,"major":0,"patch":0},"topicSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/wrappedValue"],"title":"Property Values","anchor":"Property-Values"},{"anchor":"Async-Evaluation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/Projection","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/projectedValue"],"title":"Async Evaluation"},{"anchor":"Property-Values","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/wrappedValue"],"title":"Property Values"},{"anchor":"Initializers","generated":true,"title":"Initializers","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:predicate:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:using:)-1cvog","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:using:)-3q72s"]}],"identifier":{"url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies","interfaceLanguage":"swift"},"sections":[],"kind":"symbol","variants":[{"paths":["\/documentation\/specificationcore\/asyncsatisfies"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"abstract":[{"type":"text","text":"A property wrapper for asynchronously evaluating specifications with async context providers."}],"primaryContentSections":[{"declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"text":"@propertyWrapper","kind":"attribute"},{"text":" ","kind":"text"},{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AsyncSatisfies","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Context","kind":"genericParameter"},{"text":">","kind":"text"}]}],"kind":"declarations"},{"kind":"content","content":[{"text":"Overview","anchor":"overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"code":"@AsyncSatisfies","type":"codeVoice"},{"type":"text","text":" is designed for scenarios where specification evaluation requires"},{"type":"text","text":" "},{"text":"asynchronous operations, such as network requests, database queries, or file I\/O.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Unlike "},{"type":"codeVoice","code":"@Satisfies"},{"type":"text","text":", this wrapper doesn’t provide automatic evaluation but instead"},{"type":"text","text":" "},{"type":"text","text":"requires explicit async evaluation via the projected value."}]},{"level":2,"text":"Key Features","type":"heading","anchor":"Key-Features"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Async Context Support","type":"text"}],"type":"strong"},{"text":": Works with context providers that provide async context","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Lazy Evaluation"}],"type":"strong"},{"type":"text","text":": Only evaluates when explicitly requested via projected value"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Error Handling","type":"text"}],"type":"strong"},{"type":"text","text":": Supports throwing async operations"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Flexible Specs","type":"text"}],"type":"strong"},{"type":"text","text":": Works with both sync and async specifications"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"No Auto-Update","type":"text"}],"type":"strong"},{"text":": Doesn’t automatically refresh; requires manual evaluation","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"text":"Usage Examples","anchor":"Usage-Examples","type":"heading"},{"type":"heading","level":3,"text":"Basic Async Evaluation","anchor":"Basic-Async-Evaluation"},{"type":"codeListing","syntax":"swift","code":["@AsyncSatisfies(provider: networkProvider, using: RemoteFeatureFlagSpec(flagKey: \"premium\"))","var hasPremiumAccess: Bool?","","\/\/ Evaluate asynchronously when needed","func checkPremiumAccess() async {","    do {","        let hasAccess = try await $hasPremiumAccess.evaluate()","        if hasAccess {","            showPremiumFeatures()","        }","    } catch {","        handleNetworkError(error)","    }","}"]},{"level":3,"type":"heading","text":"Database Query Specification","anchor":"Database-Query-Specification"},{"type":"codeListing","syntax":"swift","code":["struct DatabaseUserSpec: AsyncSpecification {","    typealias T = DatabaseContext","","    func isSatisfiedBy(_ context: DatabaseContext) async throws -> Bool {","        let user = try await context.database.fetchUser(context.userId)","        return user.isActive && user.hasValidSubscription","    }","}","","@AsyncSatisfies(provider: databaseProvider, using: DatabaseUserSpec())","var isValidUser: Bool?","","\/\/ Use in async context","let isValid = try await $isValidUser.evaluate()"]},{"level":3,"type":"heading","text":"Network-Based Feature Flags","anchor":"Network-Based-Feature-Flags"},{"type":"codeListing","syntax":"swift","code":["struct RemoteConfigSpec: AsyncSpecification {","    typealias T = NetworkContext","    let featureKey: String","","    func isSatisfiedBy(_ context: NetworkContext) async throws -> Bool {","        let config = try await context.apiClient.fetchRemoteConfig()","        return config.features[featureKey] == true","    }","}","","@AsyncSatisfies(","    provider: networkContextProvider,","    using: RemoteConfigSpec(featureKey: \"new_ui_enabled\")",")","var shouldShowNewUI: Bool?","","\/\/ Evaluate with timeout and error handling","func updateUIBasedOnRemoteConfig() async {","    do {","        let enabled = try await withTimeout(seconds: 5) {","            try await $shouldShowNewUI.evaluate()","        }","","        if enabled {","            switchToNewUI()","        }","    } catch {","        \/\/ Fall back to local configuration or default behavior","        useDefaultUI()","    }","}"]},{"level":3,"type":"heading","text":"Custom Async Predicate","anchor":"Custom-Async-Predicate"},{"type":"codeListing","syntax":"swift","code":["@AsyncSatisfies(provider: apiProvider, predicate: { context in","    let userProfile = try await context.apiClient.fetchUserProfile()","    let billingInfo = try await context.apiClient.fetchBillingInfo()","","    return userProfile.isVerified && billingInfo.isGoodStanding","})","var isEligibleUser: Bool?","","\/\/ Usage in SwiftUI with Task","struct ContentView: View {","    @AsyncSatisfies(provider: apiProvider, using: EligibilitySpec())","    var isEligible: Bool?","","    @State private var eligibilityStatus: Bool?","","    var body: some View {","        VStack {","            if let status = eligibilityStatus {","                Text(status ? \"Eligible\" : \"Not Eligible\")","            } else {","                ProgressView(\"Checking eligibility...\")","            }","        }","        .task {","            eligibilityStatus = try? await $isEligible.evaluate()","        }","    }","}"]},{"level":3,"type":"heading","text":"Combining with Regular Specifications","anchor":"Combining-with-Regular-Specifications"},{"type":"codeListing","syntax":"swift","code":["\/\/ Use regular (synchronous) specifications with async wrapper","@AsyncSatisfies(using: MaxCountSpec(counterKey: \"api_calls\", maximumCount: 100))","var canMakeAPICall: Bool?","","\/\/ This will use async context fetching but sync specification evaluation","let allowed = try await $canMakeAPICall.evaluate()"]},{"level":2,"type":"heading","text":"Important Notes","anchor":"Important-Notes"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"No Automatic Updates"}]},{"text":": Unlike ","type":"text"},{"code":"@Satisfies","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"@ObservedSatisfies","type":"codeVoice"},{"text":", this wrapper doesn’t automatically update","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Manual Evaluation","type":"text"}],"type":"strong"},{"text":": Always use ","type":"text"},{"type":"codeVoice","code":"$propertyName.evaluate()"},{"type":"text","text":" to get current results"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Error Propagation"}]},{"type":"text","text":": Any errors from context provider or specification are propagated to caller"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Context Caching"}]},{"type":"text","text":": Context is fetched fresh on each evaluation call"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Thread Safety","type":"text"}]},{"type":"text","text":": Safe to call from any thread, but context provider should handle thread safety"}]}]}],"type":"unorderedList"},{"type":"heading","text":"Performance Considerations","level":2,"anchor":"Performance-Considerations"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Context is fetched on every ","type":"text"},{"code":"evaluate()","type":"codeVoice"},{"text":" call - consider caching at the provider level","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Async specifications may have network or I\/O overhead"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Consider using timeouts for network-based specifications"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use appropriate error handling and fallback mechanisms","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"A property wrapper for asynchronously evaluating specifications with async context providers and async specifications.","type":"text"}],"type":"paragraph"},{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"inlineContent":[{"code":"@AsyncSatisfies","type":"codeVoice"},{"text":" is designed for scenarios where specification evaluation requires asynchronous operations like network requests, database queries, or file I\/O. Unlike ","type":"text"},{"isActive":true,"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Satisfies","type":"reference"},{"text":", this wrapper requires explicit async evaluation through the projected value rather than providing automatic evaluation.","type":"text"}],"type":"paragraph"},{"anchor":"Key-Benefits","type":"heading","text":"Key Benefits","level":3},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Async Context Support"}]},{"type":"text","text":": Works with context providers that provide async context"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Async Specifications"}]},{"text":": Supports both sync and async specification evaluation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Lazy Evaluation"}],"type":"strong"},{"text":": Only evaluates when explicitly requested","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Error Handling","type":"text"}]},{"type":"text","text":": Propagates errors from async operations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Flexible Usage","type":"text"}],"type":"strong"},{"text":": Works with regular specifications or async-specific ones","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Thread-Safe"}]},{"text":": Safe to call from any thread","type":"text"}]}]}]},{"anchor":"When-to-Use-AsyncSatisfies","text":"When to Use @AsyncSatisfies","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"@AsyncSatisfies"},{"type":"text","text":" when you need to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Evaluate specifications with network-based context or data","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Perform database queries during specification evaluation"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Handle file I\/O or other async operations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Work with remote configuration or feature flags"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Integrate with async-first APIs or services"}]}]}],"type":"unorderedList"},{"text":"Quick Example","level":2,"anchor":"Quick-Example","type":"heading"},{"syntax":"swift","type":"codeListing","code":["import SpecificationCore","","@AsyncSatisfies(","    provider: networkProvider,","    using: RemoteFeatureFlagSpec(flagKey: \"premium_features\")",")","var hasPremiumAccess: Bool?","","\/\/ Evaluate asynchronously when needed","func checkAccess() async {","    do {","        let hasAccess = try await $hasPremiumAccess.evaluate()","        if hasAccess {","            showPremiumFeatures()","        }","    } catch {","        handleNetworkError(error)","    }","}"]},{"text":"Creating @AsyncSatisfies","type":"heading","level":2,"anchor":"Creating-AsyncSatisfies"},{"text":"With Async Specification","type":"heading","level":3,"anchor":"With-Async-Specification"},{"code":["struct RemoteConfigSpec: AsyncSpecification {","    typealias T = NetworkContext","    let featureKey: String","","    func isSatisfiedBy(_ context: NetworkContext) async throws -> Bool {","        let config = try await context.apiClient.fetchRemoteConfig()","        return config.features[featureKey] == true","    }","}","","@AsyncSatisfies(","    provider: networkContextProvider,","    using: RemoteConfigSpec(featureKey: \"new_ui\")",")","var shouldShowNewUI: Bool?","","\/\/ Evaluate","let enabled = try await $shouldShowNewUI.evaluate()"],"type":"codeListing","syntax":"swift"},{"text":"With Regular Specification","type":"heading","level":3,"anchor":"With-Regular-Specification"},{"code":["\/\/ Use regular (synchronous) specifications with async wrapper","@AsyncSatisfies(","    provider: asyncProvider,","    using: MaxCountSpec(counterKey: \"api_calls\", maximumCount: 100)",")","var canMakeAPICall: Bool?","","\/\/ This uses async context fetching but sync specification evaluation","let allowed = try await $canMakeAPICall.evaluate()"],"type":"codeListing","syntax":"swift"},{"text":"With Async Predicate","type":"heading","level":3,"anchor":"With-Async-Predicate"},{"code":["@AsyncSatisfies(provider: apiProvider, predicate: { context in","    let userProfile = try await context.apiClient.fetchUserProfile()","    let billingInfo = try await context.apiClient.fetchBillingInfo()","","    return userProfile.isVerified && billingInfo.isGoodStanding","})","var isEligibleUser: Bool?"],"type":"codeListing","syntax":"swift"},{"text":"How It Works","type":"heading","level":2,"anchor":"How-It-Works"},{"inlineContent":[{"text":"The wrapper requires explicit async evaluation through the projected value:","type":"text"}],"type":"paragraph"},{"code":["@AsyncSatisfies(provider: asyncProvider, using: SomeSpec())","var isConditionMet: Bool?","","\/\/ wrappedValue is always nil (no automatic evaluation)","print(isConditionMet)  \/\/ nil","","\/\/ Use projected value to evaluate asynchronously","let result = try await $isConditionMet.evaluate()","print(result)  \/\/ true or false"],"type":"codeListing","syntax":"swift"},{"text":"Usage Examples","type":"heading","level":2,"anchor":"Usage-Examples"},{"text":"Network-Based Feature Flags","type":"heading","level":3,"anchor":"Network-Based-Feature-Flags"},{"code":["struct NetworkContext {","    let apiClient: APIClient","    let userId: String","}","","struct RemoteFeatureFlagSpec: AsyncSpecification {","    typealias T = NetworkContext","    let flagKey: String","","    func isSatisfiedBy(_ context: NetworkContext) async throws -> Bool {","        let response = try await context.apiClient.get(","            \"\/feature-flags\/\\(context.userId)\"","        )","        return response.flags[flagKey] as? Bool ?? false","    }","}","","@AsyncSatisfies(","    provider: networkProvider,","    using: RemoteFeatureFlagSpec(flagKey: \"experimental_features\")",")","var hasExperimentalFeatures: Bool?","","func loadFeatures() async {","    do {","        let enabled = try await $hasExperimentalFeatures.evaluate()","        if enabled {","            loadExperimentalFeatures()","        } else {","            loadStandardFeatures()","        }","    } catch {","        \/\/ Fall back to local configuration","        loadStandardFeatures()","        logError(\"Failed to fetch remote config: \\(error)\")","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Database User Validation","type":"heading","level":3,"anchor":"Database-User-Validation"},{"type":"codeListing","code":["struct DatabaseContext {","    let database: Database","    let userId: UUID","}","","struct ActiveUserSpec: AsyncSpecification {","    typealias T = DatabaseContext","","    func isSatisfiedBy(_ context: DatabaseContext) async throws -> Bool {","        let user = try await context.database.fetchUser(context.userId)","        return user.isActive &&","               user.hasValidSubscription &&","               !user.isBanned","    }","}","","@AsyncSatisfies(","    provider: databaseProvider,","    using: ActiveUserSpec()",")","var isActiveUser: Bool?","","func checkUserStatus() async throws {","    let isActive = try await $isActiveUser.evaluate()","","    if isActive {","        grantAccess()","    } else {","        denyAccess()","    }","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"API Rate Limit Check","anchor":"API-Rate-Limit-Check"},{"type":"codeListing","code":["struct RateLimitContext {","    let apiClient: APIClient","    let accountId: String","}","","struct RateLimitSpec: AsyncSpecification {","    typealias T = RateLimitContext","","    func isSatisfiedBy(_ context: RateLimitContext) async throws -> Bool {","        let limits = try await context.apiClient.getRateLimits(","            accountId: context.accountId","        )","        return limits.remainingRequests > 0","    }","}","","@AsyncSatisfies(","    provider: rateLimitProvider,","    using: RateLimitSpec()",")","var canMakeRequest: Bool?","","func performAPICall() async throws {","    let allowed = try await $canMakeRequest.evaluate()","","    guard allowed else {","        throw APIError.rateLimitExceeded","    }","","    let response = try await makeAPICall()","    return response","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"File-Based Configuration","anchor":"File-Based-Configuration"},{"type":"codeListing","code":["struct FileContext {","    let configPath: String","}","","struct ConfigurationValidSpec: AsyncSpecification {","    typealias T = FileContext","","    func isSatisfiedBy(_ context: FileContext) async throws -> Bool {","        let data = try await FileManager.default.readFile(at: context.configPath)","        let config = try JSONDecoder().decode(Configuration.self, from: data)","        return config.isValid && config.version >= requiredVersion","    }","}","","@AsyncSatisfies(","    provider: fileProvider,","    using: ConfigurationValidSpec()",")","var hasValidConfiguration: Bool?","","func loadApp() async {","    do {","        let isValid = try await $hasValidConfiguration.evaluate()","","        if isValid {","            startApp()","        } else {","            showConfigurationError()","        }","    } catch {","        useDefaultConfiguration()","    }","}"],"syntax":"swift"},{"text":"Real-World Examples","level":2,"anchor":"Real-World-Examples","type":"heading"},{"text":"Remote Configuration Manager","level":3,"anchor":"Remote-Configuration-Manager","type":"heading"},{"syntax":"swift","type":"codeListing","code":["class RemoteConfigManager {","    struct RemoteContext {","        let apiClient: APIClient","        let deviceId: String","        let appVersion: String","    }","","    struct FeatureEnabledSpec: AsyncSpecification {","        typealias T = RemoteContext","        let feature: String","","        func isSatisfiedBy(_ context: RemoteContext) async throws -> Bool {","            let config = try await context.apiClient.fetchConfig(","                deviceId: context.deviceId,","                appVersion: context.appVersion","            )","","            \/\/ Check if feature is enabled with rollout percentage","            guard let featureConfig = config.features[feature] else {","                return false","            }","","            if featureConfig.rolloutPercentage >= 100 {","                return true","            }","","            \/\/ Use device ID for consistent rollout","            let hash = context.deviceId.hashValue","            let bucket = abs(hash % 100)","            return bucket < featureConfig.rolloutPercentage","        }","    }","","    @AsyncSatisfies(","        provider: remoteProvider,","        using: FeatureEnabledSpec(feature: \"new_payment_flow\")","    )","    var useNewPaymentFlow: Bool?","","    @AsyncSatisfies(","        provider: remoteProvider,","        using: FeatureEnabledSpec(feature: \"enhanced_analytics\")","    )","    var enableEnhancedAnalytics: Bool?","","    func configureApp() async {","        do {","            async let paymentFlow = $useNewPaymentFlow.evaluate()","            async let analytics = $enableEnhancedAnalytics.evaluate()","","            let (useNew, enhancedAnalytics) = try await (paymentFlow, analytics)","","            if useNew {","                configureNewPaymentFlow()","            }","","            if enhancedAnalytics {","                enableDetailedAnalytics()","            }","        } catch {","            \/\/ Use default configuration","            useDefaultConfiguration()","            logError(\"Remote config failed: \\(error)\")","        }","    }","}"]},{"text":"Subscription Verification System","level":3,"anchor":"Subscription-Verification-System","type":"heading"},{"syntax":"swift","type":"codeListing","code":["class SubscriptionVerifier {","    struct VerificationContext {","        let apiClient: APIClient","        let receiptData: Data","        let userId: String","    }","","    struct ActiveSubscriptionSpec: AsyncSpecification {","        typealias T = VerificationContext","","        func isSatisfiedBy(_ context: VerificationContext) async throws -> Bool {","            \/\/ Verify with App Store","            let verification = try await context.apiClient.verifyReceipt(","                receiptData: context.receiptData","            )","","            guard verification.status == .valid else {","                return false","            }","","            \/\/ Check subscription status in backend","            let subscription = try await context.apiClient.getSubscription(","                userId: context.userId","            )","","            return subscription.isActive &&","                   subscription.expirationDate > Date() &&","                   !subscription.isCancelled","        }","    }","","    @AsyncSatisfies(","        provider: verificationProvider,","        using: ActiveSubscriptionSpec()","    )","    var hasActiveSubscription: Bool?","","    func checkSubscriptionStatus() async -> SubscriptionStatus {","        do {","            let isActive = try await $hasActiveSubscription.evaluate()","","            if isActive {","                return .active","            } else {","                return .expired","            }","        } catch let error as VerificationError {","            switch error {","            case .networkError:","                return .verificationFailed(retryable: true)","            case .invalidReceipt:","                return .invalid","            case .serverError:","                return .verificationFailed(retryable: true)","            }","        } catch {","            return .unknown","        }","    }","}"]},{"text":"Multi-Service Eligibility Check","level":3,"anchor":"Multi-Service-Eligibility-Check","type":"heading"},{"syntax":"swift","type":"codeListing","code":["class EligibilityChecker {","    struct ServiceContext {","        let userService: UserService","        let billingService: BillingService","        let complianceService: ComplianceService","        let userId: UUID","    }","","    struct FullAccessSpec: AsyncSpecification {","        typealias T = ServiceContext","","        func isSatisfiedBy(_ context: ServiceContext) async throws -> Bool {","            \/\/ Fetch data from multiple services in parallel","            async let user = context.userService.fetchUser(context.userId)","            async let billing = context.billingService.getBillingStatus(context.userId)","            async let compliance = context.complianceService.checkCompliance(context.userId)","","            let (userData, billingData, complianceData) = try await (user, billing, compliance)","","            \/\/ Check all conditions","            return userData.isVerified &&","                   userData.accountStatus == .active &&","                   billingData.isGoodStanding &&","                   billingData.hasActivePaymentMethod &&","                   complianceData.isCompliant &&","                   !complianceData.hasRestrictions","        }","    }","","    @AsyncSatisfies(","        provider: serviceProvider,","        using: FullAccessSpec()","    )","    var hasFullAccess: Bool?","","    func determineAccessLevel() async -> AccessLevel {","        do {","            let hasAccess = try await $hasFullAccess.evaluate()","","            if hasAccess {","                return .full","            } else {","                return .restricted","            }","        } catch {","            \/\/ Conservative fallback","            return .denied","        }","    }","}"]},{"text":"SwiftUI Integration","level":3,"anchor":"SwiftUI-Integration","type":"heading"},{"syntax":"swift","type":"codeListing","code":["import SwiftUI","","struct PremiumContentView: View {","    @AsyncSatisfies(","        provider: networkProvider,","        using: PremiumAccessSpec()","    )","    var hasPremiumAccess: Bool?","","    @State private var accessStatus: AccessStatus = .checking","    @State private var showError = false","    @State private var errorMessage = \"\"","","    enum AccessStatus {","        case checking","        case granted","        case denied","    }","","    var body: some View {","        Group {","            switch accessStatus {","            case .checking:","                ProgressView(\"Verifying access...\")","","            case .granted:","                PremiumContentUI()","","            case .denied:","                AccessDeniedView()","                    .button(\"Upgrade\") {","                        showUpgradeFlow()","                    }","            }","        }","        .task {","            await checkAccess()","        }","        .alert(\"Error\", isPresented: $showError) {","            Button(\"Retry\") {","                Task { await checkAccess() }","            }","            Button(\"Cancel\", role: .cancel) {}","        } message: {","            Text(errorMessage)","        }","    }","","    func checkAccess() async {","        accessStatus = .checking","","        do {","            let hasAccess = try await withTimeout(seconds: 10) {","                try await $hasPremiumAccess.evaluate()","            }","","            accessStatus = hasAccess ? .granted : .denied","        } catch {","            errorMessage = error.localizedDescription","            showError = true","            accessStatus = .denied","        }","    }","}"]},{"text":"Error Handling","level":2,"anchor":"Error-Handling","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Handle errors from async evaluation:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["@AsyncSatisfies(provider: networkProvider, using: RemoteSpec())","var isEnabled: Bool?","","func checkFeature() async {","    do {","        let enabled = try await $isEnabled.evaluate()","        \/\/ Handle result","    } catch let error as NetworkError {","        switch error {","        case .timeout:","            \/\/ Retry or use cached value","            useCachedValue()","        case .serverError:","            \/\/ Show error to user","            showErrorMessage()","        case .noConnection:","            \/\/ Offline mode","            enterOfflineMode()","        }","    } catch {","        \/\/ Handle unexpected errors","        logError(error)","        useDefaultBehavior()","    }","}"]},{"text":"Timeout Handling","level":2,"anchor":"Timeout-Handling","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Add timeouts to async evaluation:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["@AsyncSatisfies(provider: apiProvider, using: SlowAPISpec())","var shouldEnable: Bool?","","func checkWithTimeout() async {","    do {","        let result = try await withTimeout(seconds: 5) {","            try await $shouldEnable.evaluate()","        }","","        if result {","            enableFeature()","        }","    } catch is TimeoutError {","        \/\/ Use default on timeout","        useDefaultValue()","    } catch {","        handleError(error)","    }","}","","\/\/ Helper function","func withTimeout<T>(","    seconds: TimeInterval,","    operation: @escaping () async throws -> T",") async throws -> T {","    try await withThrowingTaskGroup(of: T.self) { group in","        group.addTask {","            try await operation()","        }","","        group.addTask {","            try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))","            throw TimeoutError()","        }","","        let result = try await group.next()!","        group.cancelAll()","        return result","    }","}"]},{"text":"Testing","level":2,"anchor":"Testing","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Test async evaluation with ","type":"text"},{"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider","isActive":true},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["func testAsyncEvaluation() async throws {","    let provider = MockContextProvider()","        .withFlag(\"remote_feature\", value: true)","","    @AsyncSatisfies(","        provider: provider,","        using: FeatureFlagSpec(flagKey: \"remote_feature\")","    )","    var isEnabled: Bool?","","    \/\/ wrappedValue is always nil","    XCTAssertNil(isEnabled)","","    \/\/ Evaluate asynchronously","    let result = try await $isEnabled.evaluate()","    XCTAssertTrue(result)","","    \/\/ Update context","    provider.setFlag(\"remote_feature\", to: false)","    let updatedResult = try await $isEnabled.evaluate()","    XCTAssertFalse(updatedResult)","}","","func testAsyncSpecification() async throws {","    struct MockAsyncSpec: AsyncSpecification {","        typealias T = EvaluationContext","        let delay: TimeInterval","        let result: Bool","","        func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","            try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))","            return result","        }","    }","","    let provider = MockContextProvider()","    let spec = MockAsyncSpec(delay: 0.1, result: true)","","    @AsyncSatisfies(provider: provider, using: spec)","    var condition: Bool?","","    let start = Date()","    let result = try await $condition.evaluate()","    let duration = Date().timeIntervalSince(start)","","    XCTAssertTrue(result)","    XCTAssertGreaterThan(duration, 0.1)","}","","func testErrorPropagation() async {","    struct FailingSpec: AsyncSpecification {","        typealias T = EvaluationContext","","        func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","            throw TestError.failed","        }","    }","","    let provider = MockContextProvider()","","    @AsyncSatisfies(provider: provider, using: FailingSpec())","    var condition: Bool?","","    do {","        _ = try await $condition.evaluate()","        XCTFail(\"Should have thrown error\")","    } catch is TestError {","        \/\/ Expected","    } catch {","        XCTFail(\"Wrong error type\")","    }","}"]},{"text":"Best Practices","level":2,"anchor":"Best-Practices","type":"heading"},{"text":"Use Appropriate Timeouts","level":3,"anchor":"Use-Appropriate-Timeouts","type":"heading"},{"code":["\/\/ ✅ Good - timeout for network operations","@AsyncSatisfies(provider: networkProvider, using: RemoteSpec())","var isEnabled: Bool?","","func check() async {","    do {","        let result = try await withTimeout(seconds: 10) {","            try await $isEnabled.evaluate()","        }","    } catch {","        \/\/ Handle timeout","    }","}","","\/\/ ❌ Avoid - no timeout on network operations","let result = try await $isEnabled.evaluate()  \/\/ Could hang indefinitely"],"type":"codeListing","syntax":"swift"},{"text":"Provide Fallback Behavior","level":3,"anchor":"Provide-Fallback-Behavior","type":"heading"},{"syntax":"swift","code":["\/\/ ✅ Good - fallback on error","@AsyncSatisfies(provider: apiProvider, using: RemoteConfigSpec())","var useNewFeature: Bool?","","func configureFeature() async {","    do {","        let enabled = try await $useNewFeature.evaluate()","        if enabled {","            enableNewFeature()","        }","    } catch {","        \/\/ Use safe default","        useStableFeature()","        logError(error)","    }","}"],"type":"codeListing"},{"text":"Cache Results When Appropriate","level":3,"anchor":"Cache-Results-When-Appropriate","type":"heading"},{"syntax":"swift","code":["\/\/ ✅ Good - cache for expensive operations","class ConfigManager {","    @AsyncSatisfies(provider: networkProvider, using: ConfigSpec())","    var isFeatureEnabled: Bool?","","    private var cachedResult: Bool?","    private var lastFetch: Date?","    private let cacheTimeout: TimeInterval = 300  \/\/ 5 minutes","","    func checkFeature() async throws -> Bool {","        \/\/ Use cache if valid","        if let cached = cachedResult,","           let lastFetch = lastFetch,","           Date().timeIntervalSince(lastFetch) < cacheTimeout {","            return cached","        }","","        \/\/ Fetch fresh value","        let result = try await $isFeatureEnabled.evaluate()","        cachedResult = result","        lastFetch = Date()","        return result","    }","}"],"type":"codeListing"},{"text":"Handle Errors Gracefully","level":3,"anchor":"Handle-Errors-Gracefully","type":"heading"},{"code":["\/\/ ✅ Good - specific error handling","func checkAccess() async -> AccessLevel {","    do {","        let hasAccess = try await $premiumAccess.evaluate()","        return hasAccess ? .premium : .free","    } catch is NetworkError {","        \/\/ Network issues - use cached or safe default","        return .free","    } catch is AuthenticationError {","        \/\/ Auth issues - require re-login","        return .requiresAuth","    } catch {","        \/\/ Unknown errors - safe default","        logError(error)","        return .free","    }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Performance-Considerations","text":"Performance Considerations","type":"heading","level":2},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Async Overhead","type":"text"}]},{"type":"text","text":": Async context fetching and evaluation has inherent overhead"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"No Automatic Evaluation","type":"text"}],"type":"strong"},{"text":": No performance cost unless explicitly evaluated","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"No Caching","type":"text"}],"type":"strong"},{"type":"text","text":": Context fetched fresh on each "},{"type":"codeVoice","code":"evaluate()"},{"type":"text","text":" call"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Network Latency","type":"text"}]},{"type":"text","text":": Network-based specs may have significant latency"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Error Handling Cost","type":"text"}],"type":"strong"},{"type":"text","text":": Minimal overhead for error propagation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Threading"}]},{"text":": Async evaluation can run on any thread, managed by Swift concurrency","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Consider caching at the provider or application level for frequently accessed async values.","type":"text"}],"type":"paragraph"}]}],"metadata":{"modules":[{"name":"SpecificationCore"}],"role":"symbol","title":"AsyncSatisfies","externalID":"s:17SpecificationCore14AsyncSatisfiesV","roleHeading":"Structure","symbolKind":"struct","navigatorTitle":[{"text":"AsyncSatisfies","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSatisfies"}]},"seeAlsoSections":[{"anchor":"Related-Documentation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Satisfies","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding"],"title":"Related Documentation"},{"anchor":"Property-Wrappers","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Satisfies","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Decides","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Maybe"],"generated":true,"title":"Property Wrappers"}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSpecification":{"abstract":[{"text":"A protocol for specifications that require asynchronous evaluation.","type":"text"}],"url":"\/documentation\/specificationcore\/asyncspecification","kind":"symbol","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSpecification"}],"title":"AsyncSpecification","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AsyncSpecification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MockContextProvider":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider","kind":"symbol","type":"topic","abstract":[{"text":"A mock context provider designed for unit testing.","type":"text"},{"text":" ","type":"text"},{"text":"This provider allows you to set up specific context scenarios","type":"text"},{"text":" ","type":"text"},{"text":"and verify that specifications behave correctly under controlled conditions.","type":"text"}],"title":"MockContextProvider","navigatorTitle":[{"text":"MockContextProvider","kind":"identifier"}],"url":"\/documentation\/specificationcore\/mockcontextprovider","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MockContextProvider","kind":"identifier"}],"role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies":{"navigatorTitle":[{"text":"AsyncSatisfies","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/asyncsatisfies","title":"AsyncSatisfies","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies","abstract":[{"text":"A property wrapper for asynchronously evaluating specifications with async context providers.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"AsyncSatisfies","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Satisfies":{"url":"\/documentation\/specificationcore\/satisfies","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Satisfies","role":"symbol","title":"Satisfies","abstract":[{"type":"text","text":"A property wrapper that provides declarative specification evaluation."}],"navigatorTitle":[{"kind":"identifier","text":"Satisfies"}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Satisfies","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/init(provider:using:)-3q72s":{"role":"symbol","title":"init(provider:using:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:using:)-3q72s","url":"\/documentation\/specificationcore\/asyncsatisfies\/init(provider:using:)-3q72s","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Initialize with a provider and synchronous Specification."}],"fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Provider"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Spec"},{"kind":"text","text":">("},{"kind":"externalParam","text":"provider"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV8provider5usingACyxGqd___qd_0_tc7ContextQyd__RszAA0G9ProvidingRd__AA0A0Rd_0_1TQyd_0_AHRSr0_lufc8ProviderL_qd__mfp","text":"Provider"},{"kind":"text","text":", "},{"kind":"externalParam","text":"using"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV8provider5usingACyxGqd___qd_0_tc7ContextQyd__RszAA0G9ProvidingRd__AA0A0Rd_0_1TQyd_0_AHRSr0_lufc4SpecL_qd_0_mfp","text":"Spec"},{"kind":"text","text":")"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Decides":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Decides","kind":"symbol","type":"topic","abstract":[{"text":"A property wrapper that evaluates decision specifications and always returns a non-optional result.","type":"text"}],"title":"Decides","navigatorTitle":[{"text":"Decides","kind":"identifier"}],"url":"\/documentation\/specificationcore\/decides","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Decides","kind":"identifier"}],"role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/wrappedValue":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/wrappedValue","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"The wrapped value is always "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" for async specifications."},{"type":"text","text":" "},{"type":"text","text":"Use the projected value’s "},{"type":"codeVoice","code":"evaluate()"},{"type":"text","text":" method to get the actual result."}],"title":"wrappedValue","url":"\/documentation\/specificationcore\/asyncsatisfies\/wrappedvalue","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"wrappedValue","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"},{"text":"?","kind":"text"}],"role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/init(provider:using:)-1cvog":{"url":"\/documentation\/specificationcore\/asyncsatisfies\/init(provider:using:)-1cvog","type":"topic","abstract":[{"type":"text","text":"Initialize with a provider and an asynchronous specification."}],"title":"init(provider:using:)","kind":"symbol","role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Provider","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Spec","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"provider","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV8provider5usingACyxGqd___qd_0_tc7ContextQyd__RszAA0G9ProvidingRd__AA0cA0Rd_0_1TQyd_0_AHRSr0_lufc8ProviderL_qd__mfp","text":"Provider","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"using","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV8provider5usingACyxGqd___qd_0_tc7ContextQyd__RszAA0G9ProvidingRd__AA0cA0Rd_0_1TQyd_0_AHRSr0_lufc4SpecL_qd_0_mfp","text":"Spec","kind":"typeIdentifier"},{"text":")","kind":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:using:)-1cvog"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/Projection":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Projection"}],"title":"AsyncSatisfies.Projection","url":"\/documentation\/specificationcore\/asyncsatisfies\/projection","kind":"symbol","abstract":[{"text":"Provides async evaluation capabilities for the specification.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/Projection","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Projection"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Maybe":{"navigatorTitle":[{"text":"Maybe","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/maybe","title":"Maybe","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Maybe","abstract":[{"text":"A property wrapper that evaluates decision specifications and returns an optional result.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Maybe","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/init(provider:predicate:)":{"url":"\/documentation\/specificationcore\/asyncsatisfies\/init(provider:predicate:)","abstract":[{"type":"text","text":"Initialize with a provider and a predicate."}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/init(provider:predicate:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"text":"Provider","kind":"genericParameter"},{"kind":"text","text":">("},{"kind":"externalParam","text":"provider"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV8provider9predicateACyxGqd___Sbxctc7ContextQyd__RszAA0G9ProvidingRd__lufc8ProviderL_qd__mfp","text":"Provider","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"predicate","kind":"externalParam"},{"kind":"text","text":": ("},{"text":"Context","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV7Contextxmfp"},{"text":") -> ","kind":"text"},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"},{"kind":"text","text":")"}],"title":"init(provider:predicate:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies/projectedValue":{"role":"symbol","kind":"symbol","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"projectedValue","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Projection","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore14AsyncSatisfiesV10ProjectionV"}],"title":"projectedValue","type":"topic","url":"\/documentation\/specificationcore\/asyncsatisfies\/projectedvalue","abstract":[{"type":"text","text":"The projected value providing access to async evaluation methods."},{"type":"text","text":" "},{"type":"text","text":"Use "},{"code":"$propertyName.evaluate()","type":"codeVoice"},{"type":"text","text":" to evaluate the specification asynchronously."}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies\/projectedValue"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/ContextProviding":{"role":"symbol","title":"ContextProviding","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding","url":"\/documentation\/specificationcore\/contextproviding","kind":"symbol","navigatorTitle":[{"text":"ContextProviding","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A protocol for types that can provide context for specification evaluation."},{"type":"text","text":" "},{"type":"text","text":"This enables dependency injection and testing by abstracting context creation."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContextProviding","kind":"identifier"}]}}}