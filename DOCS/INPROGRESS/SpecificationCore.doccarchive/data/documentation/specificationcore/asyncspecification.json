{"relationshipsSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification"],"type":"conformingTypes","kind":"relationships","title":"Conforming Types"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"seeAlsoSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification"],"anchor":"Related-Documentation","title":"Related Documentation"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DecisionSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding"],"generated":true,"anchor":"Essentials","title":"Essentials"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/specificationcore\/asyncspecification"]}],"sections":[],"abstract":[{"text":"A protocol for specifications that require asynchronous evaluation.","type":"text"}],"topicSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification\/isSatisfiedBy(_:)"],"anchor":"Essential-Protocol","title":"Essential Protocol"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification"],"anchor":"Type-Erasure","title":"Type Erasure"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies"],"anchor":"Property-Wrappers","title":"Property Wrappers"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification"],"anchor":"Bridging","title":"Bridging"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification\/T"],"generated":true,"anchor":"Associated-Types","title":"Associated Types"}],"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"kind":"symbol","metadata":{"symbolKind":"protocol","roleHeading":"Protocol","role":"symbol","modules":[{"name":"SpecificationCore"}],"title":"AsyncSpecification","navigatorTitle":[{"text":"AsyncSpecification","kind":"identifier"}],"externalID":"s:17SpecificationCore05AsyncA0P","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSpecification"}]},"primaryContentSections":[{"declarations":[{"platforms":["macOS"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSpecification"}],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"anchor":"overview","type":"heading","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AsyncSpecification"},{"type":"text","text":" extends the specification pattern to support async operations"},{"type":"text","text":" "},{"type":"text","text":"such as network requests, database queries, file I\/O, or any evaluation that"},{"type":"text","text":" "},{"type":"text","text":"needs to be performed asynchronously. This protocol follows the same pattern"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":"Specification"},{"type":"text","text":" but allows for async\/await and error handling."}]},{"level":2,"text":"Usage Examples","anchor":"Usage-Examples","type":"heading"},{"level":3,"text":"Network-Based Specification","anchor":"Network-Based-Specification","type":"heading"},{"syntax":"swift","code":["struct RemoteFeatureFlagSpec: AsyncSpecification {","    typealias T = EvaluationContext","","    let flagKey: String","    let apiClient: APIClient","","    func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","        let flags = try await apiClient.fetchFeatureFlags(for: context.userId)","        return flags[flagKey] == true","    }","}","","@AsyncSatisfies(using: RemoteFeatureFlagSpec(flagKey: \"premium_features\", apiClient: client))","var hasPremiumFeatures: Bool","","let isEligible = try await $hasPremiumFeatures.evaluateAsync()"],"type":"codeListing"},{"level":3,"text":"Database Query Specification","anchor":"Database-Query-Specification","type":"heading"},{"syntax":"swift","code":["struct UserSubscriptionSpec: AsyncSpecification {","    typealias T = EvaluationContext","","    let database: Database","","    func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","        let subscription = try await database.fetchSubscription(userId: context.userId)","        return subscription?.isActive == true && !subscription.isExpired","    }","}"],"type":"codeListing"},{"level":3,"text":"Complex Async Logic with Multiple Sources","anchor":"Complex-Async-Logic-with-Multiple-Sources","type":"heading"},{"syntax":"swift","code":["struct EligibilityCheckSpec: AsyncSpecification {","    typealias T = EvaluationContext","","    let userService: UserService","    let billingService: BillingService","","    func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","        async let userProfile = userService.fetchProfile(context.userId)","        async let billingStatus = billingService.checkStatus(context.userId)","","        let (profile, billing) = try await (userProfile, billingStatus)","","        return profile.isVerified && billing.isGoodStanding","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"A protocol for specifications that require asynchronous evaluation."}],"type":"paragraph"},{"level":2,"text":"Overview","anchor":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"The "},{"code":"AsyncSpecification","type":"codeVoice"},{"type":"text","text":" protocol extends the Specification Pattern to support async operations such as network requests, database queries, file I\/O, or any evaluation that needs to be performed asynchronously. It follows the same pattern as "},{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","type":"reference","isActive":true},{"type":"text","text":" but leverages Swift’s async\/await for non-blocking evaluation."}],"type":"paragraph"},{"level":3,"text":"Key Benefits","anchor":"Key-Benefits","type":"heading"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Non-Blocking Evaluation","type":"text"}],"type":"strong"},{"text":": Perform expensive operations without blocking the calling thread","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Error Handling","type":"text"}]},{"type":"text","text":": Built-in support for throwing errors during evaluation"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Async\/Await Support"}]},{"type":"text","text":": Leverage Swift’s modern concurrency features"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Type Safety"}]},{"type":"text","text":": Generic associated type ensures compile-time correctness"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Composability","type":"text"}],"type":"strong"},{"text":": Works with standard specifications through bridging","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","text":"When to Use AsyncSpecification","anchor":"When-to-Use-AsyncSpecification"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"AsyncSpecification"},{"type":"text","text":" when you need to:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Query remote APIs or services","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Access databases or file systems","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Perform long-running computations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Coordinate multiple async data sources","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Evaluate specifications that depend on I\/O","type":"text"}]}]}]},{"level":2,"type":"heading","text":"Quick Example","anchor":"Quick-Example"},{"type":"codeListing","syntax":"swift","code":["import SpecificationCore","","struct User {","    let id: String","    let email: String","}","","\/\/ Define an async specification","struct SubscriptionActiveSpec: AsyncSpecification {","    let apiClient: SubscriptionAPI","","    func isSatisfiedBy(_ user: User) async throws -> Bool {","        let subscription = try await apiClient.fetchSubscription(userId: user.id)","        return subscription.isActive && !subscription.isExpired","    }","}","","\/\/ Use the async specification","let spec = SubscriptionActiveSpec(apiClient: client)","let user = User(id: \"123\", email: \"user@example.com\")","","do {","    let isActive = try await spec.isSatisfiedBy(user)","    if isActive {","        print(\"User has active subscription\")","    }","} catch {","    print(\"Error checking subscription: \\(error)\")","}"]},{"text":"Bridging Synchronous Specifications","anchor":"Bridging-Synchronous-Specifications","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Convert any synchronous "},{"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","isActive":true},{"type":"text","text":" to async using "},{"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification","isActive":true},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct LocalUserSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.email.contains(\"@\")","    }","}","","\/\/ Bridge to async","let asyncSpec = AnyAsyncSpecification(LocalUserSpec())","","let result = try await asyncSpec.isSatisfiedBy(user)  \/\/ Works in async context"]},{"text":"Using with Property Wrappers","anchor":"Using-with-Property-Wrappers","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Combine async specifications with the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies"},{"type":"text","text":" property wrapper:"}]},{"type":"codeListing","syntax":"swift","code":["struct FeatureViewModel {","    let user: User","","    @AsyncSatisfies(using: SubscriptionActiveSpec(apiClient: client))","    var hasActiveSubscription: Bool","","    init(user: User) {","        self.user = user","        _hasActiveSubscription = AsyncSatisfies(","            using: SubscriptionActiveSpec(apiClient: client),","            with: user","        )","    }","","    func checkAccess() async throws -> Bool {","        try await $hasActiveSubscription.evaluateAsync()","    }","}","","let viewModel = FeatureViewModel(user: user)","let hasAccess = try await viewModel.checkAccess()"]},{"text":"Network-Based Specifications","anchor":"Network-Based-Specifications","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Query remote APIs to evaluate specifications:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct RemoteFeatureFlagSpec: AsyncSpecification {","    let flagKey: String","    let apiClient: FeatureFlagAPI","","    func isSatisfiedBy(_ context: EvaluationContext) async throws -> Bool {","        let flags = try await apiClient.fetchFlags(userId: context.userId)","        return flags[flagKey] == true","    }","}","","\/\/ Use with remote feature flags","let premiumFeaturesSpec = RemoteFeatureFlagSpec(","    flagKey: \"premium_features\",","    apiClient: client",")","","if try await premiumFeaturesSpec.isSatisfiedBy(context) {","    \/\/ Enable premium features","}"]},{"type":"heading","anchor":"Database-Query-Specifications","text":"Database Query Specifications","level":2},{"type":"paragraph","inlineContent":[{"text":"Access databases asynchronously:","type":"text"}]},{"type":"codeListing","code":["struct UserHasPurchasedSpec: AsyncSpecification {","    let database: Database","    let productId: String","","    func isSatisfiedBy(_ user: User) async throws -> Bool {","        let purchases = try await database.fetchPurchases(userId: user.id)","        return purchases.contains { $0.productId == productId }","    }","}","","\/\/ Check purchase history","let hasProVersion = UserHasPurchasedSpec(","    database: db,","    productId: \"pro_version\"",")","","if try await hasProVersion.isSatisfiedBy(user) {","    \/\/ Grant pro features","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Coordinating Multiple Async Sources","anchor":"Coordinating-Multiple-Async-Sources"},{"type":"paragraph","inlineContent":[{"text":"Use async\/let for concurrent evaluation:","type":"text"}]},{"type":"codeListing","code":["struct EligibilityCheckSpec: AsyncSpecification {","    let userService: UserService","    let billingService: BillingService","    let complianceService: ComplianceService","","    func isSatisfiedBy(_ user: User) async throws -> Bool {","        \/\/ Fetch all data concurrently","        async let profile = userService.fetchProfile(user.id)","        async let billing = billingService.checkStatus(user.id)","        async let compliance = complianceService.verifyUser(user.id)","","        \/\/ Wait for all results","        let (userProfile, billingStatus, complianceStatus) =","            try await (profile, billing, compliance)","","        \/\/ Evaluate combined criteria","        return userProfile.isVerified &&","               billingStatus.isGoodStanding &&","               complianceStatus.isCompliant","    }","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Type-Erased Async Specifications","anchor":"Type-Erased-Async-Specifications"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification"},{"type":"text","text":" for flexibility:"}]},{"syntax":"swift","code":["\/\/ Store different async specs together","let asyncChecks: [AnyAsyncSpecification<User>] = [","    AnyAsyncSpecification(SubscriptionActiveSpec(apiClient: client)),","    AnyAsyncSpecification(UserHasPurchasedSpec(database: db, productId: \"premium\")),","    AnyAsyncSpecification { user in","        \/\/ Custom async logic","        try await customCheck(user)","    }","]","","\/\/ Evaluate all checks","for check in asyncChecks {","    let result = try await check.isSatisfiedBy(user)","    print(\"Check result: \\(result)\")","}"],"type":"codeListing"},{"anchor":"Creating-from-Closures","text":"Creating from Closures","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Create async specifications from closures:","type":"text"}]},{"syntax":"swift","code":["let delayedSpec = AnyAsyncSpecification<User> { user in","    \/\/ Simulate network delay","    try await Task.sleep(nanoseconds: 100_000_000)  \/\/ 0.1 seconds","    return user.email.contains(\"@verified.com\")","}","","let isVerified = try await delayedSpec.isSatisfiedBy(user)"],"type":"codeListing"},{"anchor":"Error-Handling-Patterns","type":"heading","level":2,"text":"Error Handling Patterns"},{"anchor":"Try-Catch-Pattern","type":"heading","level":3,"text":"Try-Catch Pattern"},{"type":"codeListing","code":["do {","    let isEligible = try await spec.isSatisfiedBy(user)","    if isEligible {","        \/\/ Proceed with action","    }","} catch let error as NetworkError {","    print(\"Network error: \\(error.localizedDescription)\")","} catch {","    print(\"Unexpected error: \\(error)\")","}"],"syntax":"swift"},{"level":3,"type":"heading","anchor":"Optional-Result-Pattern","text":"Optional Result Pattern"},{"type":"codeListing","code":["func evaluateSpec(_ user: User) async -> Bool {","    do {","        return try await spec.isSatisfiedBy(user)","    } catch {","        print(\"Error evaluating spec: \\(error)\")","        return false  \/\/ Safe default","    }","}"],"syntax":"swift"},{"level":3,"type":"heading","anchor":"Result-Type-Pattern","text":"Result Type Pattern"},{"type":"codeListing","syntax":"swift","code":["func evaluateSpec(_ user: User) async -> Result<Bool, Error> {","    do {","        let result = try await spec.isSatisfiedBy(user)","        return .success(result)","    } catch {","        return .failure(error)","    }","}","","let result = await evaluateSpec(user)","switch result {","case .success(let isEligible):","    print(\"Eligible: \\(isEligible)\")","case .failure(let error):","    print(\"Error: \\(error)\")","}"]},{"text":"Timeout Handling","level":2,"type":"heading","anchor":"Timeout-Handling"},{"type":"paragraph","inlineContent":[{"text":"Add timeouts to async specification evaluation:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct TimeoutAsyncSpec<S: AsyncSpecification>: AsyncSpecification {","    let wrapped: S","    let timeout: Duration","","    func isSatisfiedBy(_ candidate: S.T) async throws -> Bool {","        try await withThrowingTaskGroup(of: Bool.self) { group in","            group.addTask {","                try await self.wrapped.isSatisfiedBy(candidate)","            }","            group.addTask {","                try await Task.sleep(for: self.timeout)","                throw TimeoutError()","            }","","            let result = try await group.next()!","            group.cancelAll()","            return result","        }","    }","}","","\/\/ Use with timeout","let timedSpec = TimeoutAsyncSpec(","    wrapped: RemoteFeatureFlagSpec(flagKey: \"feature\", apiClient: client),","    timeout: .seconds(5)",")"]},{"type":"heading","level":2,"text":"Caching Async Results","anchor":"Caching-Async-Results"},{"type":"paragraph","inlineContent":[{"text":"Cache expensive async evaluations:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["actor CachedAsyncSpec<S: AsyncSpecification>: AsyncSpecification where S.T: Hashable {","    let wrapped: S","    var cache: [S.T: Bool] = [:]","","    init(_ spec: S) {","        self.wrapped = spec","    }","","    func isSatisfiedBy(_ candidate: S.T) async throws -> Bool {","        if let cached = cache[candidate] {","            return cached","        }","","        let result = try await wrapped.isSatisfiedBy(candidate)","        cache[candidate] = result","        return result","    }","","    func clearCache() {","        cache.removeAll()","    }","}","","\/\/ Use cached spec","let cachedSpec = CachedAsyncSpec(","    SubscriptionActiveSpec(apiClient: client)",")","","let result1 = try await cachedSpec.isSatisfiedBy(user)  \/\/ Fetches from API","let result2 = try await cachedSpec.isSatisfiedBy(user)  \/\/ Returns cached value"]},{"text":"Best Practices","type":"heading","level":2,"anchor":"Best-Practices"},{"type":"heading","level":3,"text":"Use Structured Concurrency","anchor":"Use-Structured-Concurrency"},{"syntax":"swift","code":["\/\/ ✅ Good - use async\/let for concurrent operations","async let check1 = spec1.isSatisfiedBy(user)","async let check2 = spec2.isSatisfiedBy(user)","let (result1, result2) = try await (check1, check2)","","\/\/ ❌ Avoid - sequential when could be concurrent","let result1 = try await spec1.isSatisfiedBy(user)","let result2 = try await spec2.isSatisfiedBy(user)"],"type":"codeListing"},{"level":3,"anchor":"Handle-Errors-Appropriately","text":"Handle Errors Appropriately","type":"heading"},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - specific error handling","do {","    return try await spec.isSatisfiedBy(user)","} catch is NetworkError {","    return false  \/\/ Safe default for network errors","} catch is DatabaseError {","    throw  \/\/ Propagate database errors","}","","\/\/ ❌ Avoid - swallowing all errors silently","let result = (try? await spec.isSatisfiedBy(user)) ?? false"]},{"type":"heading","text":"Provide Cancellation Support","anchor":"Provide-Cancellation-Support","level":3},{"type":"codeListing","code":["\/\/ ✅ Good - check for cancellation","func isSatisfiedBy(_ user: User) async throws -> Bool {","    try Task.checkCancellation()","","    let data = try await fetchData(for: user)","","    try Task.checkCancellation()","","    return processData(data)","}"],"syntax":"swift"},{"level":2,"text":"Performance Considerations","type":"heading","anchor":"Performance-Considerations"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Concurrent Evaluation"}],"type":"strong"},{"text":": Use async\/let to evaluate multiple async specs concurrently","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Caching"}],"type":"strong"},{"type":"text","text":": Cache results of expensive async operations when appropriate"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Timeouts"}],"type":"strong"},{"type":"text","text":": Add timeouts to prevent indefinite waiting"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Cancellation"}],"type":"strong"},{"type":"text","text":": Support task cancellation for long-running operations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Resource Management"}]},{"text":": Clean up resources properly in async contexts","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSpecification/T":{"fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"T"}],"type":"topic","kind":"symbol","required":true,"abstract":[{"type":"text","text":"The type of candidate that this specification evaluates"}],"url":"\/documentation\/specificationcore\/asyncspecification\/t","title":"T","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification\/T","role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnyAsyncSpecification":{"type":"topic","navigatorTitle":[{"text":"AnyAsyncSpecification","kind":"identifier"}],"title":"AnyAsyncSpecification","url":"\/documentation\/specificationcore\/anyasyncspecification","kind":"symbol","abstract":[{"type":"text","text":"A type-erased wrapper for any asynchronous specification."}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnyAsyncSpecification","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyAsyncSpecification","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSpecification/isSatisfiedBy(_:)":{"url":"\/documentation\/specificationcore\/asyncspecification\/issatisfiedby(_:)","type":"topic","kind":"symbol","title":"isSatisfiedBy(_:)","abstract":[{"type":"text","text":"Asynchronously determines whether the given candidate satisfies this specification"}],"role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"isSatisfiedBy"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"T","preciseIdentifier":"s:17SpecificationCore05AsyncA0P1TQa"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification\/isSatisfiedBy(_:)","required":true},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DecisionSpec":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DecisionSpec","kind":"identifier"}],"type":"topic","kind":"symbol","abstract":[{"text":"A protocol for specifications that can return a typed result instead of just a boolean.","type":"text"},{"text":" ","type":"text"},{"text":"This extends the specification pattern to support decision-making with payload results.","type":"text"}],"url":"\/documentation\/specificationcore\/decisionspec","title":"DecisionSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DecisionSpec","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DecisionSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSatisfies":{"navigatorTitle":[{"text":"AsyncSatisfies","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/asyncsatisfies","title":"AsyncSatisfies","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSatisfies","abstract":[{"text":"A property wrapper for asynchronously evaluating specifications with async context providers.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"AsyncSatisfies","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AsyncSpecification":{"abstract":[{"text":"A protocol for specifications that require asynchronous evaluation.","type":"text"}],"url":"\/documentation\/specificationcore\/asyncspecification","kind":"symbol","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AsyncSpecification","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncSpecification"}],"title":"AsyncSpecification","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AsyncSpecification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/ContextProviding":{"role":"symbol","title":"ContextProviding","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/ContextProviding","url":"\/documentation\/specificationcore\/contextproviding","kind":"symbol","navigatorTitle":[{"text":"ContextProviding","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A protocol for types that can provide context for specification evaluation."},{"type":"text","text":" "},{"type":"text","text":"This enables dependency injection and testing by abstracting context creation."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContextProviding","kind":"identifier"}]}}}