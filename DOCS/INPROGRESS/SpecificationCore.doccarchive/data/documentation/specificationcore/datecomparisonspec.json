{"metadata":{"modules":[{"name":"SpecificationCore"}],"title":"DateComparisonSpec","navigatorTitle":[{"kind":"identifier","text":"DateComparisonSpec"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DateComparisonSpec","kind":"identifier"}],"roleHeading":"Structure","symbolKind":"struct","role":"symbol","externalID":"s:17SpecificationCore18DateComparisonSpecV"},"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"variants":[{"paths":["\/documentation\/specificationcore\/datecomparisonspec"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"seeAlsoSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec"],"generated":true,"title":"Basic Specifications","anchor":"Basic-Specifications"}],"relationshipsSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification"],"kind":"relationships","type":"conformsTo","title":"Conforms To"}],"kind":"symbol","abstract":[{"type":"text","text":"Compares the date of a stored event to a reference date using before\/after."}],"topicSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/init(eventKey:comparison:date:)"],"title":"Creating Specifications","anchor":"Creating-Specifications"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/Comparison"],"title":"Comparison Types","anchor":"Comparison-Types"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/isSatisfiedBy(_:)"],"generated":true,"title":"Instance Methods","anchor":"Instance-Methods"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/T"],"generated":true,"title":"Type Aliases","anchor":"Type-Aliases"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/Specification-Implementations"],"generated":true,"title":"Default Implementations","anchor":"Default-Implementations"}],"sections":[],"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DateComparisonSpec"}]}]},{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A specification that compares a stored event date to a reference date."}]},{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"DateComparisonSpec"},{"type":"text","text":" checks whether an event occurred before or after a specific reference date. This is useful for determining if events happened within certain timeframes, validating chronological ordering, or implementing date-based eligibility rules."}]},{"type":"heading","text":"Key Benefits","level":3,"anchor":"Key-Benefits"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Event Chronology"}]},{"type":"text","text":": Verify when events occurred relative to dates"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Simple Comparisons"}]},{"type":"text","text":": Before\/after logic with clear semantics"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Event-Based","type":"text"}]},{"type":"text","text":": Works with "},{"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","isActive":true},{"type":"text","text":" event timestamps"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Eligibility Checking","type":"text"}],"type":"strong"},{"text":": Determine if events meet date requirements","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Deadline Enforcement"}]},{"type":"text","text":": Check if events occurred before deadlines"}],"type":"paragraph"}]}]},{"anchor":"When-to-Use-DateComparisonSpec","level":3,"type":"heading","text":"When to Use DateComparisonSpec"},{"inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"DateComparisonSpec"},{"type":"text","text":" when you need to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Check if an event occurred before a deadline"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify events happened after a start date"}]}]},{"content":[{"inlineContent":[{"text":"Enforce chronological ordering of events","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Validate event timing for eligibility"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Compare event dates to milestones","type":"text"}]}]}],"type":"unorderedList"},{"level":2,"type":"heading","text":"Quick Example","anchor":"Quick-Example"},{"code":["import SpecificationCore","","\/\/ Record when user registered","let provider = DefaultContextProvider.shared","provider.recordEvent(\"user_registered\")","","\/\/ Check if registration was before a cutoff date","let cutoffDate = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 31",").date!","","let eligibilitySpec = DateComparisonSpec(","    eventKey: \"user_registered\",","    comparison: .before,","    date: cutoffDate",")","","let context = provider.currentContext()","","if eligibilitySpec.isSatisfiedBy(context) {","    grantEarlyAdopterBenefits()","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Creating DateComparisonSpec","anchor":"Creating-DateComparisonSpec"},{"code":["\/\/ Check if event occurred before a date","let beforeSpec = DateComparisonSpec(","    eventKey: \"action_taken\",","    comparison: .before,","    date: referenceDate",")","","\/\/ Check if event occurred after a date","let afterSpec = DateComparisonSpec(","    eventKey: \"action_taken\",","    comparison: .after,","    date: referenceDate",")"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Comparison Types","anchor":"Comparison-Types"},{"level":3,"type":"heading","text":"Before Comparison","anchor":"Before-Comparison"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Event date must be strictly less than reference date:"}]},{"code":["let deadline = Date(timeIntervalSince1970: 2000)","let spec = DateComparisonSpec(","    eventKey: \"submission\",","    comparison: .before,","    date: deadline",")","","\/\/ Event at 1500: satisfied ✅ (1500 < 2000)","\/\/ Event at 2000: NOT satisfied ❌ (2000 < 2000 is false)","\/\/ Event at 2500: NOT satisfied ❌ (2500 < 2000 is false)"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"After Comparison","anchor":"After-Comparison"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Event date must be strictly greater than reference date:"}]},{"code":["let startDate = Date(timeIntervalSince1970: 1000)","let spec = DateComparisonSpec(","    eventKey: \"enrollment\",","    comparison: .after,","    date: startDate",")","","\/\/ Event at 500: NOT satisfied ❌ (500 > 1000 is false)","\/\/ Event at 1000: NOT satisfied ❌ (1000 > 1000 is false)","\/\/ Event at 1500: satisfied ✅ (1500 > 1000)"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Usage Examples","anchor":"Usage-Examples"},{"level":3,"type":"heading","text":"Early Registration Benefit","anchor":"Early-Registration-Benefit"},{"code":["\/\/ Give benefits to users who registered before Jan 1, 2025","let cutoffDate = DateComponents(","    calendar: .current,","    year: 2025,","    month: 1,","    day: 1,","    hour: 0,","    minute: 0",").date!","","let earlyUserSpec = DateComparisonSpec(","    eventKey: \"user_registered\",","    comparison: .before,","    date: cutoffDate",")","","@Satisfies(using: earlyUserSpec)","var isEarlyAdopter: Bool","","if isEarlyAdopter {","    grantLifetimeDiscount()","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","anchor":"Contest-Deadline","text":"Contest Deadline"},{"type":"codeListing","syntax":"swift","code":["\/\/ Check if submission was before contest deadline","let contestDeadline = DateComponents(","    calendar: .current,","    year: 2025,","    month: 6,","    day: 30,","    hour: 23,","    minute: 59",").date!","","let validSubmissionSpec = DateComparisonSpec(","    eventKey: \"contest_submission\",","    comparison: .before,","    date: contestDeadline",")","","func validateSubmission() -> Bool {","    let context = DefaultContextProvider.shared.currentContext()","    return validSubmissionSpec.isSatisfiedBy(context)","}"]},{"anchor":"Beta-Access-Gate","text":"Beta Access Gate","type":"heading","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ Beta opened on a specific date - check if user enrolled after","let betaStartDate = DateComponents(","    calendar: .current,","    year: 2025,","    month: 3,","    day: 1",").date!","","let betaEligibilitySpec = DateComparisonSpec(","    eventKey: \"beta_enrollment\",","    comparison: .after,","    date: betaStartDate",")","","@Satisfies(using: betaEligibilitySpec)","var enrolledDuringBeta: Bool"]},{"level":3,"anchor":"Milestone-Verification","type":"heading","text":"Milestone Verification"},{"syntax":"swift","type":"codeListing","code":["\/\/ Check if milestone was reached after launch date","let launchDate = DateComponents(","    calendar: .current,","    year: 2025,","    month: 1,","    day: 15",").date!","","let postLaunchSpec = DateComparisonSpec(","    eventKey: \"milestone_reached\",","    comparison: .after,","    date: launchDate",")","","func trackPostLaunchMilestone() {","    let context = DefaultContextProvider.shared.currentContext()","","    if postLaunchSpec.isSatisfiedBy(context) {","        recordAsPostLaunchAchievement()","    }","}"]},{"type":"heading","level":2,"text":"Real-World Examples","anchor":"Real-World-Examples"},{"type":"heading","level":3,"text":"Grandfathered Pricing","anchor":"Grandfathered-Pricing"},{"code":["class PricingManager {","    let pricingChangeDate = DateComponents(","        calendar: .current,","        year: 2025,","        month: 7,","        day: 1","    ).date!","","    \/\/ Users who subscribed before price change get old pricing","    lazy var grandfatheredSpec = DateComparisonSpec(","        eventKey: \"subscription_started\",","        comparison: .before,","        date: pricingChangeDate","    )","","    func getMonthlyPrice(for user: User) -> Decimal {","        let context = DefaultContextProvider.shared.currentContext()","","        if grandfatheredSpec.isSatisfiedBy(context) {","            return 9.99  \/\/ Old pricing","        } else {","            return 14.99  \/\/ New pricing","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Event-Attendance-Verification","type":"heading","level":3,"text":"Event Attendance Verification"},{"code":["struct ConferenceManager {","    let conferenceDate = DateComponents(","        calendar: .current,","        year: 2025,","        month: 9,","        day: 15","    ).date!","","    \/\/ Check if user registered before conference","    lazy var preRegistrationSpec = DateComparisonSpec(","        eventKey: \"conference_registration\",","        comparison: .before,","        date: conferenceDate","    )","","    \/\/ Check if user checked in after conference started","    lazy var attendanceSpec = DateComparisonSpec(","        eventKey: \"conference_checkin\",","        comparison: .after,","        date: conferenceDate","    )","","    func getAttendanceStatus() -> AttendanceStatus {","        let context = DefaultContextProvider.shared.currentContext()","","        let preRegistered = preRegistrationSpec.isSatisfiedBy(context)","        let checkedIn = attendanceSpec.isSatisfiedBy(context)","","        if preRegistered && checkedIn {","            return .attended","        } else if preRegistered {","            return .registered","        } else {","            return .notRegistered","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Warranty-Validation","text":"Warranty Validation","type":"heading","level":3},{"type":"codeListing","syntax":"swift","code":["class WarrantyManager {","    func createWarrantySpec(","        purchaseEventKey: String,","        warrantyMonths: Int","    ) -> DateComparisonSpec {","        let purchaseDate = DefaultContextProvider.shared","            .getEvent(purchaseEventKey) ?? Date()","","        let expirationDate = Calendar.current.date(","            byAdding: .month,","            value: warrantyMonths,","            to: purchaseDate","        )!","","        \/\/ Warranty valid if current date is before expiration","        return DateComparisonSpec(","            eventKey: purchaseEventKey,","            comparison: .before,","            date: expirationDate","        )","    }","","    func isWarrantyValid(for product: Product) -> Bool {","        let spec = createWarrantySpec(","            purchaseEventKey: \"purchase_\\(product.id)\",","            warrantyMonths: 12","        )","","        let context = DefaultContextProvider.shared.currentContext()","        return spec.isSatisfiedBy(context)","    }","}"]},{"text":"Missing Event Behavior","type":"heading","anchor":"Missing-Event-Behavior","level":2},{"type":"paragraph","inlineContent":[{"text":"If the event doesn’t exist, the specification returns ","type":"text"},{"type":"codeVoice","code":"false"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let spec = DateComparisonSpec(","    eventKey: \"never_recorded\",","    comparison: .before,","    date: someDate",")","","let context = DefaultContextProvider.shared.currentContext()","","\/\/ Returns false because event doesn't exist","spec.isSatisfiedBy(context)  \/\/ false"]},{"text":"Testing","type":"heading","anchor":"Testing","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test date comparisons with "},{"type":"reference","isActive":true,"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["func testEventBefore() {","    let eventDate = Date(timeIntervalSince1970: 1000)","    let referenceDate = Date(timeIntervalSince1970: 2000)","","    let provider = MockContextProvider()","        .withEvent(\"action\", date: eventDate)","        .withCurrentDate(Date())","","    let spec = DateComparisonSpec(","        eventKey: \"action\",","        comparison: .before,","        date: referenceDate","    )","","    \/\/ Event at 1000 is before 2000","    XCTAssertTrue(spec.isSatisfiedBy(provider.currentContext()))","}","","func testEventAfter() {","    let eventDate = Date(timeIntervalSince1970: 2000)","    let referenceDate = Date(timeIntervalSince1970: 1000)","","    let provider = MockContextProvider()","        .withEvent(\"action\", date: eventDate)","","    let spec = DateComparisonSpec(","        eventKey: \"action\",","        comparison: .after,","        date: referenceDate","    )","","    \/\/ Event at 2000 is after 1000","    XCTAssertTrue(spec.isSatisfiedBy(provider.currentContext()))","}","","func testMissingEvent() {","    let provider = MockContextProvider()","","    let spec = DateComparisonSpec(","        eventKey: \"never_happened\",","        comparison: .before,","        date: Date()","    )","","    \/\/ Should return false (no event)","    XCTAssertFalse(spec.isSatisfiedBy(provider.currentContext()))","}","","func testEventAtBoundary() {","    let date = Date(timeIntervalSince1970: 1000)","","    let provider = MockContextProvider()","        .withEvent(\"action\", date: date)","","    \/\/ Before comparison with same date","    let beforeSpec = DateComparisonSpec(","        eventKey: \"action\",","        comparison: .before,","        date: date","    )","    XCTAssertFalse(beforeSpec.isSatisfiedBy(provider.currentContext()))","","    \/\/ After comparison with same date","    let afterSpec = DateComparisonSpec(","        eventKey: \"action\",","        comparison: .after,","        date: date","    )","    XCTAssertFalse(afterSpec.isSatisfiedBy(provider.currentContext()))","}"]},{"text":"Best Practices","type":"heading","anchor":"Best-Practices","level":2},{"text":"Record Events at the Right Time","type":"heading","anchor":"Record-Events-at-the-Right-Time","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - record event when it actually happens","func submitEntry() {","    performSubmission()","    DefaultContextProvider.shared.recordEvent(\"contest_submission\")","}","","\/\/ ❌ Avoid - recording before action completes","func submitEntry() {","    DefaultContextProvider.shared.recordEvent(\"contest_submission\")","    performSubmission()  \/\/ Might fail","}"]},{"text":"Use Descriptive Event Keys","type":"heading","anchor":"Use-Descriptive-Event-Keys","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - clear, specific keys","\"user_registered\"","\"subscription_started\"","\"contest_submission\"","","\/\/ ❌ Avoid - ambiguous keys","\"event1\"","\"date\"","\"timestamp\""]},{"text":"Consider Boundary Cases","type":"heading","anchor":"Consider-Boundary-Cases","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - handle exact equality explicitly","\/\/ Use .before for \"must happen before deadline\"","\/\/ Use .after for \"must happen after start\"","","\/\/ ❌ Avoid - assuming equal dates satisfy spec","\/\/ Both .before and .after return false for equal dates"]},{"text":"Validate Event Exists","type":"heading","anchor":"Validate-Event-Exists","level":3},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - check if event exists first","let provider = DefaultContextProvider.shared","","if provider.getEvent(\"important_event\") != nil {","    let spec = DateComparisonSpec(","        eventKey: \"important_event\",","        comparison: .before,","        date: deadline","    )","    \/\/ Use spec","}","","\/\/ Or handle false result appropriately","let result = spec.isSatisfiedBy(context)","if !result {","    \/\/ Could be false because event doesn't exist","    \/\/ Or because comparison failed","}"]},{"text":"Performance Considerations","type":"heading","anchor":"Performance-Considerations","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Event Lookup","type":"text"}],"type":"strong"},{"text":": O(1) dictionary access","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Date Comparison","type":"text"}]},{"type":"text","text":": Simple comparison operator"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"No Computation"}]},{"type":"text","text":": No complex date arithmetic"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Missing Events"}]},{"type":"text","text":": Fast path returns false immediately"}],"type":"paragraph"}]}]}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec"},"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec","url":"\/documentation\/specificationcore\/daterangespec","abstract":[{"text":"Succeeds when ","type":"text"},{"type":"codeVoice","code":"currentDate"},{"type":"text","text":" is within the inclusive range [start, end]."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"DateRangeSpec","kind":"identifier"}],"title":"DateRangeSpec","type":"topic","role":"symbol","navigatorTitle":[{"text":"DateRangeSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MockContextProvider":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider","kind":"symbol","type":"topic","abstract":[{"text":"A mock context provider designed for unit testing.","type":"text"},{"text":" ","type":"text"},{"text":"This provider allows you to set up specific context scenarios","type":"text"},{"text":" ","type":"text"},{"text":"and verify that specifications behave correctly under controlled conditions.","type":"text"}],"title":"MockContextProvider","navigatorTitle":[{"text":"MockContextProvider","kind":"identifier"}],"url":"\/documentation\/specificationcore\/mockcontextprovider","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MockContextProvider","kind":"identifier"}],"role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/CooldownIntervalSpec":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CooldownIntervalSpec"}],"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"A specification that ensures enough time has passed since the last occurrence of an event."},{"type":"text","text":" "},{"type":"text","text":"This is particularly useful for implementing cooldown periods for actions like showing banners,"},{"type":"text","text":" "},{"type":"text","text":"notifications, or any other time-sensitive operations that shouldn’t happen too frequently."}],"url":"\/documentation\/specificationcore\/cooldownintervalspec","title":"CooldownIntervalSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"CooldownIntervalSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec/isSatisfiedBy(_:)":{"type":"topic","url":"\/documentation\/specificationcore\/datecomparisonspec\/issatisfiedby(_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/isSatisfiedBy(_:)","role":"symbol","title":"isSatisfiedBy(_:)","abstract":[{"text":"Evaluates whether the given context satisfies this specification.","type":"text"}],"kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"isSatisfiedBy","kind":"identifier"},{"text":"(","kind":"text"},{"text":"EvaluationContext","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV"},{"text":") -> ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec/Comparison":{"title":"DateComparisonSpec.Comparison","kind":"symbol","type":"topic","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"Comparison"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/Comparison","role":"symbol","url":"\/documentation\/specificationcore\/datecomparisonspec\/comparison","fragments":[{"text":"enum","kind":"keyword"},{"kind":"text","text":" "},{"text":"Comparison","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MaxCountSpec":{"navigatorTitle":[{"text":"MaxCountSpec","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/maxcountspec","title":"MaxCountSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","abstract":[{"type":"text","text":"A specification that checks if a counter is below a maximum threshold."},{"type":"text","text":" "},{"type":"text","text":"This is useful for implementing limits on actions, display counts, or usage restrictions."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxCountSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec":{"role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PredicateSpec","kind":"identifier"}],"abstract":[{"text":"A specification that accepts a closure for arbitrary logic.","type":"text"},{"text":" ","type":"text"},{"text":"This provides maximum flexibility for custom business rules that don’t fit","type":"text"},{"text":" ","type":"text"},{"text":"into the standard specification patterns.","type":"text"}],"type":"topic","url":"\/documentation\/specificationcore\/predicatespec","title":"PredicateSpec","navigatorTitle":[{"text":"PredicateSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec/Specification-Implementations":{"type":"topic","url":"\/documentation\/specificationcore\/datecomparisonspec\/specification-implementations","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/Specification-Implementations","role":"collectionGroup","title":"Specification Implementations","abstract":[],"kind":"article"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/FirstMatchSpec":{"url":"\/documentation\/specificationcore\/firstmatchspec","type":"topic","navigatorTitle":[{"text":"FirstMatchSpec","kind":"identifier"}],"abstract":[{"text":"A decision specification that evaluates child specifications in order and returns","type":"text"},{"text":" ","type":"text"},{"text":"the result of the first one that is satisfied.","type":"text"}],"title":"FirstMatchSpec","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FirstMatchSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec":{"type":"topic","navigatorTitle":[{"text":"DateComparisonSpec","kind":"identifier"}],"title":"DateComparisonSpec","url":"\/documentation\/specificationcore\/datecomparisonspec","kind":"symbol","abstract":[{"text":"Compares the date of a stored event to a reference date using before\/after.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DateComparisonSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec/init(eventKey:comparison:date:)":{"url":"\/documentation\/specificationcore\/datecomparisonspec\/init(eventkey:comparison:date:)","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/init(eventKey:comparison:date:)","role":"symbol","title":"init(eventKey:comparison:date:)","abstract":[],"kind":"symbol","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"eventKey"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":", "},{"kind":"externalParam","text":"comparison"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SpecificationCore18DateComparisonSpecV0D0O","kind":"typeIdentifier","text":"Comparison"},{"kind":"text","text":", "},{"text":"date","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:10Foundation4DateV","text":"Date","kind":"typeIdentifier"},{"text":")","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/TimeSinceEventSpec":{"url":"\/documentation\/specificationcore\/timesinceeventspec","abstract":[{"type":"text","text":"A specification that checks if a minimum duration has passed since a specific event."},{"type":"text","text":" "},{"text":"This is useful for implementing cooldown periods, delays, or time-based restrictions.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","role":"symbol","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"TimeSinceEventSpec"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TimeSinceEventSpec","kind":"identifier"}],"title":"TimeSinceEventSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec/T":{"type":"topic","url":"\/documentation\/specificationcore\/datecomparisonspec\/t","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec\/T","role":"symbol","title":"DateComparisonSpec.T","abstract":[{"type":"text","text":"The type of context that this specification evaluates."}],"navigatorTitle":[{"kind":"identifier","text":"T"}],"kind":"symbol","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"T","kind":"identifier"}]}}}