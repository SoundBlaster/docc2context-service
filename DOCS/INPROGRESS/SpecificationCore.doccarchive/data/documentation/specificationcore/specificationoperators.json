{"schemaVersion":{"patch":0,"major":0,"minor":3},"seeAlsoSections":[{"title":"Related Documentation","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationBuilder"],"anchor":"Related-Documentation"}],"identifier":{"url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationOperators","interfaceLanguage":"swift"},"variants":[{"paths":["\/documentation\/specificationcore\/specificationoperators"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"abstract":[{"text":"Operators, functions, and builders for composing specifications with elegant syntax.","type":"text"}],"topicSections":[{"title":"Logical Operators","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/&&(_:_:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/__(_:_:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/!(_:)"],"anchor":"Logical-Operators"},{"title":"Convenience Functions","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/spec(_:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/alwaysTrue()","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/alwaysFalse()"],"anchor":"Convenience-Functions"},{"title":"Builder Pattern","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationBuilder"],"anchor":"Builder-Pattern"},{"title":"Related Concepts","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification"],"anchor":"Related-Concepts"}],"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"kind":"article","metadata":{"title":"Specification Operators and Builders","modules":[{"name":"SpecificationCore"}],"role":"collectionGroup","roleHeading":"API Collection"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SpecificationCore provides a rich set of operators, convenience functions, and builder patterns that make composing specifications more expressive and readable. These utilities complement the core "},{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","type":"reference","isActive":true},{"type":"text","text":" protocol with Swift-native operators and fluent interfaces."}]},{"anchor":"Whats-Included","type":"heading","level":3,"text":"What’s Included"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Logical Operators","type":"text"}],"type":"strong"},{"text":": ","type":"text"},{"code":"&&","type":"codeVoice"},{"text":", ","type":"text"},{"code":"||","type":"codeVoice"},{"text":", ","type":"text"},{"code":"!","type":"codeVoice"},{"text":" for boolean composition","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Convenience Functions","type":"text"}]},{"type":"text","text":": "},{"code":"spec()","type":"codeVoice"},{"type":"text","text":", "},{"code":"alwaysTrue()","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"alwaysFalse()"},{"type":"text","text":" for quick creation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Builder Pattern"}]},{"type":"text","text":": "},{"isActive":true,"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationBuilder"},{"type":"text","text":" for fluent composition"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Global Functions"}]},{"type":"text","text":": "},{"type":"codeVoice","code":"build()"},{"type":"text","text":" for starting builder chains"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","text":"When to Use These Utilities","level":3,"anchor":"When-to-Use-These-Utilities"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use specification operators and builders when you want to:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Write more concise and readable composition code"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use familiar Swift operators for logical operations","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Build specifications fluently with method chaining","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Create specifications from closures quickly"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Construct complex specifications step-by-step"}]}]}]},{"type":"heading","text":"Quick Example","level":2,"anchor":"Quick-Example"},{"type":"codeListing","syntax":"swift","code":["import SpecificationCore","","struct User {","    let age: Int","    let isActive: Bool","    let isPremium: Bool","}","","struct AdultSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.age >= 18","    }","}","","struct ActiveSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.isActive","    }","}","","\/\/ Using operators","let eligibleSpec = AdultSpec() && ActiveSpec() || PremiumSpec()","","\/\/ Using convenience functions","let customSpec = spec<User> { $0.age >= 21 }","","\/\/ Using builder pattern","let builtSpec = build(AdultSpec())","    .and(ActiveSpec())","    .or(PremiumSpec())","    .build()"]},{"type":"heading","level":2,"text":"Logical Operators","anchor":"Logical-Operators"},{"level":3,"text":"AND Operator (&&)","type":"heading","anchor":"AND-Operator-"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Combines two specifications with AND logic:"}]},{"type":"codeListing","syntax":"swift","code":["let adultSpec = AdultSpec()","let activeSpec = ActiveSpec()","","\/\/ Using method syntax","let combined1 = adultSpec.and(activeSpec)","","\/\/ Using operator syntax (more concise)","let combined2 = adultSpec && activeSpec","","\/\/ Both are equivalent","let user = User(age: 25, isActive: true, isPremium: false)","combined1.isSatisfiedBy(user)  \/\/ true","combined2.isSatisfiedBy(user)  \/\/ true"]},{"level":3,"text":"OR Operator (||)","type":"heading","anchor":"OR-Operator-%7C%7C"},{"type":"paragraph","inlineContent":[{"text":"Combines two specifications with OR logic:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let premiumSpec = PremiumSpec()","let trialSpec = TrialSpec()","","\/\/ Using method syntax","let hasAccess1 = premiumSpec.or(trialSpec)","","\/\/ Using operator syntax","let hasAccess2 = premiumSpec || trialSpec","","\/\/ Satisfied if user is premium OR trial","hasAccess2.isSatisfiedBy(user)"]},{"level":3,"anchor":"NOT-Operator-","text":"NOT Operator (!)","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Negates a specification:","type":"text"}]},{"code":["let activeSpec = ActiveSpec()","","\/\/ Using method syntax","let inactive1 = activeSpec.not()","","\/\/ Using operator syntax (prefix)","let inactive2 = !activeSpec","","\/\/ Satisfied when user is NOT active","inactive2.isSatisfiedBy(user)"],"type":"codeListing","syntax":"swift"},{"text":"Operator Precedence","type":"heading","level":3,"anchor":"Operator-Precedence"},{"type":"paragraph","inlineContent":[{"text":"Operators follow standard Swift precedence rules:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ AND has higher precedence than OR","let spec1 = adultSpec && activeSpec || premiumSpec","\/\/ Equivalent to:","let spec2 = (adultSpec && activeSpec) || premiumSpec","","\/\/ Use parentheses for clarity","let spec3 = adultSpec && (activeSpec || premiumSpec)","","\/\/ NOT has highest precedence","let spec4 = !adultSpec && activeSpec","\/\/ Equivalent to:","let spec5 = (!adultSpec) && activeSpec"]},{"text":"Complex Composition","level":2,"anchor":"Complex-Composition","type":"heading"},{"inlineContent":[{"text":"Combine operators for complex logic:","type":"text"}],"type":"paragraph"},{"code":["struct VerifiedSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.emailVerified","    }","}","","struct BannedSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.isBanned","    }","}","","\/\/ Complex eligibility: (adult AND active) OR premium, AND NOT banned","let eligibilitySpec =","    (AdultSpec() && ActiveSpec() || PremiumSpec()) &&","    !BannedSpec() &&","    VerifiedSpec()","","if eligibilitySpec.isSatisfiedBy(user) {","    print(\"User is eligible\")","}"],"type":"codeListing","syntax":"swift"},{"text":"Convenience Functions","level":2,"type":"heading","anchor":"Convenience-Functions"},{"level":3,"type":"heading","anchor":"spec-Function","text":"spec() Function"},{"inlineContent":[{"type":"text","text":"Create specifications quickly from closures:"}],"type":"paragraph"},{"code":["\/\/ Instead of creating a struct","struct EmailValidSpec: Specification {","    func isSatisfiedBy(_ user: User) -> Bool {","        user.email.contains(\"@\")","    }","}","","\/\/ Use spec() for inline creation","let emailValid = spec<User> { user in","    user.email.contains(\"@\")","}","","\/\/ Even more concise with shorthand","let emailValid2 = spec<User> { $0.email.contains(\"@\") }","","\/\/ Compose with other specs","let verifiedUser = spec<User> { $0.emailVerified } &&","                   spec<User> { $0.age >= 18 }"],"type":"codeListing","syntax":"swift"},{"anchor":"alwaysTrue-Function","type":"heading","text":"alwaysTrue() Function","level":3},{"inlineContent":[{"text":"Create a specification that always returns true:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let always = alwaysTrue<User>()","","always.isSatisfiedBy(anyUser)  \/\/ Always true","","\/\/ Useful for conditional logic","let spec = isFeatureEnabled","    ? ActualSpec()","    : alwaysTrue<User>()"],"syntax":"swift"},{"level":3,"type":"heading","text":"alwaysFalse() Function","anchor":"alwaysFalse-Function"},{"inlineContent":[{"text":"Create a specification that always returns false:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let never = alwaysFalse<User>()","","never.isSatisfiedBy(anyUser)  \/\/ Always false","","\/\/ Useful for disabling features","let spec = isMaintenanceMode","    ? alwaysFalse<User>()","    : NormalSpec()"],"type":"codeListing"},{"anchor":"Builder-Pattern","type":"heading","text":"Builder Pattern","level":2},{"inlineContent":[{"type":"reference","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationBuilder","isActive":true},{"type":"text","text":" provides a fluent interface for step-by-step composition:"}],"type":"paragraph"},{"type":"heading","text":"Basic Builder Usage","level":3,"anchor":"Basic-Builder-Usage"},{"type":"codeListing","code":["let spec = build(AdultSpec())","    .and(ActiveSpec())","    .and(VerifiedSpec())","    .build()","","let isEligible = spec.isSatisfiedBy(user)"],"syntax":"swift"},{"anchor":"Starting-with-a-Predicate","text":"Starting with a Predicate","type":"heading","level":3},{"syntax":"swift","type":"codeListing","code":["let spec = build<User> { $0.age >= 18 }","    .and(spec { $0.isActive })","    .and(spec { $0.emailVerified })","    .build()"]},{"level":3,"type":"heading","text":"Complex Builder Chains","anchor":"Complex-Builder-Chains"},{"type":"codeListing","code":["let eligibilitySpec = build(BaseEligibilitySpec())","    .and(AgeRequirementSpec())","    .and(LocationSpec())","    .or(PremiumOverrideSpec())  \/\/ Premium users bypass requirements","    .and(NotBannedSpec())       \/\/ But still can't be banned","    .build()"],"syntax":"swift"},{"text":"Conditional Building","type":"heading","anchor":"Conditional-Building","level":3},{"type":"codeListing","code":["var builder = build(BaseSpec())","","if requireAdult {","    builder = builder.and(AdultSpec())","}","","if requireActive {","    builder = builder.and(ActiveSpec())","}","","if premiumOnly {","    builder = builder.and(PremiumSpec())","}","","let finalSpec = builder.build()"],"syntax":"swift"},{"type":"heading","level":3,"anchor":"Negation-in-Builder","text":"Negation in Builder"},{"type":"codeListing","syntax":"swift","code":["let spec = build(ActiveSpec())","    .and(VerifiedSpec())","    .not()  \/\/ Negate the entire chain","    .build()","","\/\/ Equivalent to: !(ActiveSpec() && VerifiedSpec())"]},{"type":"heading","level":2,"text":"Combining Operators and Builders","anchor":"Combining-Operators-and-Builders"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Mix operators and builders for maximum flexibility:"}]},{"code":["\/\/ Start with operator composition","let baseSpec = AdultSpec() && ActiveSpec()","","\/\/ Continue with builder","let fullSpec = build(baseSpec)","    .or(PremiumSpec())","    .and(VerifiedSpec())","    .build()","","\/\/ Or use operators on built specs","let built = build(Spec1()).and(Spec2()).build()","let final = built && Spec3() || Spec4()"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":2,"text":"Real-World Examples","anchor":"Real-World-Examples"},{"text":"User Access Control","level":3,"type":"heading","anchor":"User-Access-Control"},{"type":"codeListing","code":["\/\/ Readable access control logic","let canAccessPremiumContent =","    (spec<User> { $0.subscriptionTier == \"premium\" } &&","     spec<User> { $0.subscriptionExpiry > Date() }) ||","    (spec<User> { $0.isAdmin }) &&","    !spec<User> { $0.isBanned }","","if canAccessPremiumContent.isSatisfiedBy(user) {","    \/\/ Show premium content","}"],"syntax":"swift"},{"anchor":"Feature-Flag-Evaluation","type":"heading","text":"Feature Flag Evaluation","level":3},{"type":"codeListing","code":["\/\/ Complex feature flag logic","let showNewUI = build<EvaluationContext> { ctx in","    ctx.flag(for: \"new_ui_enabled\") == true","}",".and(spec { ctx in","    ctx.counter(for: \"login_count\") ?? 0 >= 5","})",".or(spec { ctx in","    ctx.flag(for: \"force_new_ui\") == true","})",".build()","","if showNewUI.isSatisfiedBy(context) {","    \/\/ Render new UI","}"],"syntax":"swift"},{"level":3,"type":"heading","anchor":"Form-Validation","text":"Form Validation"},{"type":"codeListing","syntax":"swift","code":["let isValidRegistration =","    spec<RegistrationForm> { $0.email.contains(\"@\") } &&","    spec { $0.password.count >= 8 } &&","    spec { $0.agreedToTerms } &&","    (spec { $0.age >= 18 } || spec { $0.hasParentalConsent })","","if isValidRegistration.isSatisfiedBy(form) {","    submitRegistration(form)","}"]},{"level":3,"anchor":"E-Commerce-Rules","type":"heading","text":"E-Commerce Rules"},{"type":"codeListing","syntax":"swift","code":["let qualifiesForDiscount = build<Order> { order in","    order.totalAmount >= 100","}",".and(spec { $0.itemCount >= 3 })",".or(spec { $0.customerTier == \"VIP\" })",".or(spec { $0.isFirstPurchase })",".and(!spec { $0.alreadyDiscounted })",".build()","","if qualifiesForDiscount.isSatisfiedBy(order) {","    applyDiscount(to: order)","}"]},{"type":"heading","level":2,"text":"Functional Patterns","anchor":"Functional-Patterns"},{"type":"heading","level":3,"text":"Specification Pipelines","anchor":"Specification-Pipelines"},{"code":["let pipeline = [","    spec<User> { $0.age >= 18 },","    spec<User> { $0.emailVerified },","    spec<User> { $0.isActive },","    spec<User> { !$0.isBanned }","]","","\/\/ All must pass","let allPass = pipeline.allSatisfied()","","\/\/ Any must pass","let anyPass = pipeline.anySatisfied()"],"type":"codeListing","syntax":"swift"},{"level":3,"text":"Specification Factories","anchor":"Specification-Factories","type":"heading"},{"code":["func createValidation(for type: UserType) -> AnySpecification<User> {","    switch type {","    case .admin:","        return spec { $0.role == \"admin\" } &&","               spec { $0.emailVerified }","","    case .moderator:","        return spec { $0.role == \"moderator\" } &&","               spec { $0.age >= 21 } &&","               spec { $0.backgroundCheckPassed }","","    case .user:","        return spec { $0.emailVerified } &&","               !spec { $0.isBanned }","    }","}","","let validation = createValidation(for: .admin)"],"type":"codeListing","syntax":"swift"},{"anchor":"Higher-Order-Specifications","type":"heading","level":3,"text":"Higher-Order Specifications"},{"code":["func requireAll<T>(_ requirements: [AnySpecification<T>]) -> AnySpecification<T> {","    requirements.isEmpty","        ? alwaysTrue()","        : requirements.allSatisfied()","}","","func requireAny<T>(_ options: [AnySpecification<T>]) -> AnySpecification<T> {","    options.isEmpty","        ? alwaysFalse()","        : options.anySatisfied()","}","","\/\/ Use higher-order functions","let must = requireAll([","    spec<User> { $0.age >= 18 },","    spec<User> { $0.isActive }","])","","let canBe = requireAny([","    spec<User> { $0.isPremium },","    spec<User> { $0.isAdmin }","])","","let finalSpec = must && canBe"],"syntax":"swift","type":"codeListing"},{"level":2,"type":"heading","text":"Best Practices","anchor":"Best-Practices"},{"type":"heading","text":"Use Operators for Readability","level":3,"anchor":"Use-Operators-for-Readability"},{"type":"codeListing","code":["\/\/ ✅ Good - concise and readable","let spec = adultSpec && activeSpec || premiumSpec","","\/\/ ❌ Verbose - harder to read","let spec = adultSpec.and(activeSpec).or(premiumSpec)"],"syntax":"swift"},{"text":"Use Builders for Complex Logic","type":"heading","level":3,"anchor":"Use-Builders-for-Complex-Logic"},{"syntax":"swift","code":["\/\/ ✅ Good - clear step-by-step construction","let spec = build(baseSpec)","    .and(requirement1)","    .and(requirement2)","    .or(override)","    .build()","","\/\/ ❌ Harder to read - complex operator chain","let spec = baseSpec && requirement1 && requirement2 || override"],"type":"codeListing"},{"level":3,"text":"Name Intermediate Specifications","type":"heading","anchor":"Name-Intermediate-Specifications"},{"syntax":"swift","code":["\/\/ ✅ Good - named intermediate specs","let hasValidSubscription = premiumSpec || trialSpec","let meetsAgeRequirement = adultSpec","let isEligible = hasValidSubscription && meetsAgeRequirement","","\/\/ ❌ Avoid - unnamed complex chains","let spec = premiumSpec || trialSpec && adultSpec"],"type":"codeListing"},{"text":"Use spec() for Simple Cases","anchor":"Use-spec-for-Simple-Cases","type":"heading","level":3},{"code":["\/\/ ✅ Good - inline for simple checks","let valid = spec<User> { $0.email.contains(\"@\") }","","\/\/ ❌ Overkill - creating a struct for simple predicate","struct EmailValidSpec: Specification { \/* ... *\/ }","let valid = EmailValidSpec()"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Performance Considerations","type":"heading","anchor":"Performance-Considerations"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Operator Overhead","type":"text"}]},{"type":"text","text":": Operators have no performance overhead vs method calls"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Builder Allocation","type":"text"}]},{"type":"text","text":": Builders create intermediate objects; use for readability, not performance-critical paths"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Inline Specs"}],"type":"strong"},{"text":": ","type":"text"},{"code":"spec()","type":"codeVoice"},{"text":" function creates closures; consider reusable structs for frequently called specs","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Short-Circuit Evaluation","type":"text"}]},{"type":"text","text":": && and || operators short-circuit like standard Swift operators"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/SpecificationBuilder":{"abstract":[{"text":"A builder for creating complex specifications using a fluent interface","type":"text"}],"url":"\/documentation\/specificationcore\/specificationbuilder","kind":"symbol","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/SpecificationBuilder","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"SpecificationBuilder","kind":"identifier"}],"title":"SpecificationBuilder","type":"topic","role":"symbol","navigatorTitle":[{"text":"SpecificationBuilder","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AnySpecification":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/AnySpecification","url":"\/documentation\/specificationcore\/anyspecification","kind":"symbol","abstract":[{"text":"A type-erased wrapper for any specification optimized for performance.","type":"text"},{"type":"text","text":" "},{"text":"This allows you to store specifications of different concrete types in the same collection","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or use them in contexts where the specific type isn’t known at compile time."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnySpecification","kind":"identifier"}],"title":"AnySpecification","type":"topic","role":"symbol","navigatorTitle":[{"text":"AnySpecification","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/alwaysTrue()":{"type":"topic","title":"alwaysTrue()","url":"\/documentation\/specificationcore\/alwaystrue()","kind":"symbol","abstract":[{"type":"text","text":"Creates a specification that always returns true"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/alwaysTrue()","role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"alwaysTrue","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"text":">() -> ","kind":"text"},{"text":"AnySpecification","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore10alwaysTrueAA03AnyA0VyxGylF1TL_xmfp"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/spec(_:)":{"url":"\/documentation\/specificationcore\/spec(_:)","abstract":[{"type":"text","text":"Creates a specification from a predicate function"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/spec(_:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"spec","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"text":">((","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore4specyAA03AnyA0VyxGSbxclF1TL_xmfp"},{"text":") -> ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"},{"text":") -> ","kind":"text"},{"text":"AnySpecification","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore4specyAA03AnyA0VyxGSbxclF1TL_xmfp"},{"text":">","kind":"text"}],"title":"spec(_:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/__(_:_:)":{"role":"symbol","title":"||(_:_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/__(_:_:)","url":"\/documentation\/specificationcore\/__(_:_:)","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Logical OR operator for specifications"}],"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"||","kind":"identifier"},{"text":" ","kind":"text"},{"text":"<","kind":"text"},{"text":"Left","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Right","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"Left","preciseIdentifier":"s:17SpecificationCore2oooiyAA02OrA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF4LeftL_xmfp","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Right","preciseIdentifier":"s:17SpecificationCore2oooiyAA02OrA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF5RightL_q_mfp","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"OrSpecification","preciseIdentifier":"s:17SpecificationCore02OrA0V","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Left","preciseIdentifier":"s:17SpecificationCore2oooiyAA02OrA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF4LeftL_xmfp","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Right","preciseIdentifier":"s:17SpecificationCore2oooiyAA02OrA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF5RightL_q_mfp","kind":"typeIdentifier"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/&&(_:_:)":{"role":"symbol","title":"&&(_:_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/&&(_:_:)","url":"\/documentation\/specificationcore\/&&(_:_:)","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Logical AND operator for specifications"}],"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"&&","kind":"identifier"},{"text":" ","kind":"text"},{"text":"<","kind":"text"},{"text":"Left","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Right","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"Left","preciseIdentifier":"s:17SpecificationCore2aaoiyAA03AndA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF4LeftL_xmfp","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Right","preciseIdentifier":"s:17SpecificationCore2aaoiyAA03AndA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF5RightL_q_mfp","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"AndSpecification","preciseIdentifier":"s:17SpecificationCore03AndA0V","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Left","preciseIdentifier":"s:17SpecificationCore2aaoiyAA03AndA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF4LeftL_xmfp","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Right","preciseIdentifier":"s:17SpecificationCore2aaoiyAA03AndA0Vyxq_Gx_q_tAA0A0RzAaFR_1TQy_AGRtzr0_lF5RightL_q_mfp","kind":"typeIdentifier"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/alwaysFalse()":{"url":"\/documentation\/specificationcore\/alwaysfalse()","abstract":[{"type":"text","text":"Creates a specification that always returns false"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/alwaysFalse()","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"alwaysFalse","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"text":">() -> ","kind":"text"},{"text":"AnySpecification","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore03AnyA0V"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore11alwaysFalseAA03AnyA0VyxGylF1TL_xmfp"},{"text":">","kind":"text"}],"title":"alwaysFalse()"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/!(_:)":{"url":"\/documentation\/specificationcore\/!(_:)","abstract":[{"type":"text","text":"Logical NOT operator for specifications"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/!(_:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"!","kind":"identifier"},{"text":" ","kind":"text"},{"text":"<","kind":"text"},{"text":"S","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"S","preciseIdentifier":"s:17SpecificationCore1nopyAA03NotA0VyxGxAA0A0RzlF1SL_xmfp","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"NotSpecification","preciseIdentifier":"s:17SpecificationCore03NotA0V","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"S","preciseIdentifier":"s:17SpecificationCore1nopyAA03NotA0VyxGxAA0A0RzlF1SL_xmfp","kind":"typeIdentifier"},{"text":">","kind":"text"}],"title":"!(_:)"}}}