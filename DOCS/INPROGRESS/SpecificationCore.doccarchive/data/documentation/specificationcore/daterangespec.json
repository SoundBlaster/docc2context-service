{"primaryContentSections":[{"declarations":[{"platforms":["macOS"],"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DateRangeSpec","kind":"identifier"}],"languages":["swift"]}],"kind":"declarations"},{"content":[{"text":"Overview","level":2,"type":"heading","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A specification that checks if the current date falls within an inclusive date range."}]},{"text":"Overview","level":2,"type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"code":"DateRangeSpec","type":"codeVoice"},{"text":" evaluates to true when the current date in the ","type":"text"},{"isActive":true,"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","type":"reference"},{"text":" is within the specified start and end dates (inclusive). This is useful for implementing time-limited campaigns, seasonal features, or any functionality that should only be active during a specific time period.","type":"text"}]},{"text":"Key Benefits","level":3,"type":"heading","anchor":"Key-Benefits"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Time-Limited Features"}],"type":"strong"},{"text":": Enable\/disable features during specific periods","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Campaign Management","type":"text"}]},{"type":"text","text":": Control promotional campaigns with dates"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Seasonal Content","type":"text"}]},{"text":": Show content only during relevant seasons","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Event Windows"}],"type":"strong"},{"text":": Enforce event start and end times","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Simple API"}],"type":"strong"},{"type":"text","text":": Straightforward date range checking"}]}]}]},{"text":"When to Use DateRangeSpec","level":3,"type":"heading","anchor":"When-to-Use-DateRangeSpec"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"DateRangeSpec"},{"type":"text","text":" when you need to:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Run promotional campaigns during specific dates"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Enable seasonal features or content","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Restrict functionality to event windows","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement time-limited offers"}]}]},{"content":[{"inlineContent":[{"text":"Show holiday-specific content","type":"text"}],"type":"paragraph"}]}]},{"text":"Quick Example","level":2,"type":"heading","anchor":"Quick-Example"},{"type":"codeListing","syntax":"swift","code":["import SpecificationCore","","\/\/ Define campaign dates","let campaignStart = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 1",").date!","","let campaignEnd = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 31",").date!","","\/\/ Create spec for December campaign","let holidayCampaignSpec = DateRangeSpec(","    start: campaignStart,","    end: campaignEnd",")","","\/\/ Use with context","let context = DefaultContextProvider.shared.currentContext()","","if holidayCampaignSpec.isSatisfiedBy(context) {","    showHolidayPromotion()","}"]},{"text":"Creating DateRangeSpec","level":2,"type":"heading","anchor":"Creating-DateRangeSpec"},{"type":"codeListing","syntax":"swift","code":["\/\/ Basic creation with start and end dates","let spec = DateRangeSpec(","    start: startDate,","    end: endDate",")","","\/\/ The range is inclusive: start <= currentDate <= end"]},{"text":"How It Works","level":2,"type":"heading","anchor":"How-It-Works"},{"type":"paragraph","inlineContent":[{"text":"The specification checks if current date is within the range:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let start = Date(timeIntervalSince1970: 1000)","let end = Date(timeIntervalSince1970: 2000)","let spec = DateRangeSpec(start: start, end: end)","","\/\/ Current date = 900: NOT satisfied ❌ (before start)","\/\/ Current date = 1000: satisfied ✅ (at start)","\/\/ Current date = 1500: satisfied ✅ (in middle)","\/\/ Current date = 2000: satisfied ✅ (at end)","\/\/ Current date = 2100: NOT satisfied ❌ (after end)"]},{"text":"Usage Examples","level":2,"type":"heading","anchor":"Usage-Examples"},{"text":"Promotional Campaign","level":3,"type":"heading","anchor":"Promotional-Campaign"},{"type":"codeListing","syntax":"swift","code":["\/\/ Black Friday campaign: Nov 24-27, 2025","let blackFridayStart = DateComponents(","    calendar: .current,","    year: 2025,","    month: 11,","    day: 24,","    hour: 0,","    minute: 0",").date!","","let blackFridayEnd = DateComponents(","    calendar: .current,","    year: 2025,","    month: 11,","    day: 27,","    hour: 23,","    minute: 59",").date!","","let blackFridaySpec = DateRangeSpec(","    start: blackFridayStart,","    end: blackFridayEnd",")","","@Satisfies(using: blackFridaySpec)","var isBlackFridayActive: Bool","","if isBlackFridayActive {","    applyBlackFridayDiscounts()","}"]},{"text":"Seasonal Content","level":3,"type":"heading","anchor":"Seasonal-Content"},{"type":"codeListing","syntax":"swift","code":["\/\/ Summer content: June 1 - August 31","let summerStart = DateComponents(","    calendar: .current,","    year: Calendar.current.component(.year, from: Date()),","    month: 6,","    day: 1",").date!","","let summerEnd = DateComponents(","    calendar: .current,","    year: Calendar.current.component(.year, from: Date()),","    month: 8,","    day: 31,","    hour: 23,","    minute: 59",").date!","","let summerSpec = DateRangeSpec(start: summerStart, end: summerEnd)","","struct ContentView: View {","    @Satisfies(using: summerSpec)","    var isSummerSeason: Bool","","    var body: some View {","        if isSummerSeason {","            SummerThemeView()","        } else {","            DefaultThemeView()","        }","    }","}"]},{"text":"Limited-Time Feature","level":3,"type":"heading","anchor":"Limited-Time-Feature"},{"type":"codeListing","syntax":"swift","code":["\/\/ Beta feature available for 2 weeks","let betaStart = Date()","let betaEnd = Date().addingTimeInterval(14 * 86400)  \/\/ 14 days","","let betaSpec = DateRangeSpec(start: betaStart, end: betaEnd)","","@Satisfies(using: betaSpec)","var isBetaActive: Bool","","func accessBetaFeature() {","    guard isBetaActive else {","        showExpiredMessage()","        return","    }","","    showBetaFeature()","}"]},{"text":"Event Window","level":3,"type":"heading","anchor":"Event-Window"},{"type":"codeListing","syntax":"swift","code":["\/\/ Conference dates: March 15-17, 2025","let conferenceStart = DateComponents(","    calendar: .current,","    year: 2025,","    month: 3,","    day: 15,","    hour: 9,","    minute: 0",").date!","","let conferenceEnd = DateComponents(","    calendar: .current,","    year: 2025,","    month: 3,","    day: 17,","    hour: 18,","    minute: 0",").date!","","let conferenceSpec = DateRangeSpec(","    start: conferenceStart,","    end: conferenceEnd",")","","@Satisfies(using: conferenceSpec)","var isConferenceActive: Bool","","if isConferenceActive {","    enableLiveStreamFeatures()","}"]},{"text":"Real-World Examples","level":2,"type":"heading","anchor":"Real-World-Examples"},{"text":"Multi-Phase Campaign Manager","level":3,"type":"heading","anchor":"Multi-Phase-Campaign-Manager"},{"type":"codeListing","syntax":"swift","code":["struct CampaignManager {","    enum Phase {","        case prelaunch","        case earlyBird","        case regular","        case lastChance","        case ended","","        var spec: DateRangeSpec? {","            let calendar = Calendar.current","            let year = calendar.component(.year, from: Date())","","            switch self {","            case .prelaunch:","                return DateRangeSpec(","                    start: makeDate(year, 11, 1)!,","                    end: makeDate(year, 11, 14)!","                )","            case .earlyBird:","                return DateRangeSpec(","                    start: makeDate(year, 11, 15)!,","                    end: makeDate(year, 11, 20)!","                )","            case .regular:","                return DateRangeSpec(","                    start: makeDate(year, 11, 21)!,","                    end: makeDate(year, 11, 27)!","                )","            case .lastChance:","                return DateRangeSpec(","                    start: makeDate(year, 11, 28)!,","                    end: makeDate(year, 11, 30)!","                )","            case .ended:","                return nil","            }","        }","","        private func makeDate(_ year: Int, _ month: Int, _ day: Int) -> Date? {","            DateComponents(","                calendar: .current,","                year: year,","                month: month,","                day: day","            ).date","        }","    }","","    func getCurrentPhase() -> Phase {","        let context = DefaultContextProvider.shared.currentContext()","","        for phase in [Phase.prelaunch, .earlyBird, .regular, .lastChance] {","            if let spec = phase.spec, spec.isSatisfiedBy(context) {","                return phase","            }","        }","","        return .ended","    }","","    func getDiscount(for phase: Phase) -> Double {","        switch phase {","        case .prelaunch: return 0.30","        case .earlyBird: return 0.25","        case .regular: return 0.15","        case .lastChance: return 0.10","        case .ended: return 0.0","        }","    }","}"]},{"text":"Holiday Feature Manager","level":3,"type":"heading","anchor":"Holiday-Feature-Manager"},{"type":"codeListing","syntax":"swift","code":["struct HolidayFeatureManager {","    struct Holiday {","        let name: String","        let spec: DateRangeSpec","        let theme: Theme","    }","","    let holidays: [Holiday] = [","        Holiday(","            name: \"Christmas\",","            spec: DateRangeSpec(","                start: makeDate(12, 20)!,","                end: makeDate(12, 26)!","            ),","            theme: .christmas","        ),","        Holiday(","            name: \"New Year\",","            spec: DateRangeSpec(","                start: makeDate(12, 30)!,","                end: makeDate(1, 2)!","            ),","            theme: .newYear","        ),","        Holiday(","            name: \"Valentine's Day\",","            spec: DateRangeSpec(","                start: makeDate(2, 13)!,","                end: makeDate(2, 15)!","            ),","            theme: .valentines","        )","    ]","","    func getCurrentHoliday() -> Holiday? {","        let context = DefaultContextProvider.shared.currentContext()","","        return holidays.first { holiday in","            holiday.spec.isSatisfiedBy(context)","        }","    }","","    func applyHolidayTheme() {","        if let holiday = getCurrentHoliday() {","            ThemeManager.apply(holiday.theme)","        } else {","            ThemeManager.apply(.default)","        }","    }","","    private func makeDate(_ month: Int, _ day: Int) -> Date? {","        let year = Calendar.current.component(.year, from: Date())","        return DateComponents(","            calendar: .current,","            year: year,","            month: month,","            day: day","        ).date","    }","}"]},{"text":"Trial Period Manager","level":3,"type":"heading","anchor":"Trial-Period-Manager"},{"type":"codeListing","syntax":"swift","code":["class TrialManager {","    func createTrialSpec(startDate: Date, durationDays: Int) -> DateRangeSpec {","        let endDate = startDate.addingTimeInterval(","            TimeInterval(durationDays * 86400)","        )","","        return DateRangeSpec(start: startDate, end: endDate)","    }","","    func checkTrialStatus(user: User) -> TrialStatus {","        let trialSpec = createTrialSpec(","            startDate: user.trialStartDate,","            durationDays: 14","        )","","        let context = DefaultContextProvider.shared.currentContext()","","        if trialSpec.isSatisfiedBy(context) {","            return .active","        } else {","            return .expired","        }","    }","}"]},{"type":"heading","level":2,"text":"Testing","anchor":"Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test date range logic with "},{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider","isActive":true,"type":"reference"},{"type":"text","text":":"}]},{"syntax":"swift","type":"codeListing","code":["func testWithinRange() {","    let start = Date(timeIntervalSince1970: 1000)","    let end = Date(timeIntervalSince1970: 2000)","    let current = Date(timeIntervalSince1970: 1500)","","    let provider = MockContextProvider()","        .withCurrentDate(current)","","    let spec = DateRangeSpec(start: start, end: end)","","    \/\/ Should be satisfied (1500 is within 1000-2000)","    XCTAssertTrue(spec.isSatisfiedBy(provider.currentContext()))","}","","func testBeforeRange() {","    let start = Date(timeIntervalSince1970: 1000)","    let end = Date(timeIntervalSince1970: 2000)","    let current = Date(timeIntervalSince1970: 500)","","    let provider = MockContextProvider()","        .withCurrentDate(current)","","    let spec = DateRangeSpec(start: start, end: end)","","    \/\/ Should NOT be satisfied (500 is before 1000)","    XCTAssertFalse(spec.isSatisfiedBy(provider.currentContext()))","}","","func testAfterRange() {","    let start = Date(timeIntervalSince1970: 1000)","    let end = Date(timeIntervalSince1970: 2000)","    let current = Date(timeIntervalSince1970: 2500)","","    let provider = MockContextProvider()","        .withCurrentDate(current)","","    let spec = DateRangeSpec(start: start, end: end)","","    \/\/ Should NOT be satisfied (2500 is after 2000)","    XCTAssertFalse(spec.isSatisfiedBy(provider.currentContext()))","}","","func testAtBoundaries() {","    let start = Date(timeIntervalSince1970: 1000)","    let end = Date(timeIntervalSince1970: 2000)","    let spec = DateRangeSpec(start: start, end: end)","","    \/\/ At start boundary","    let atStart = MockContextProvider()","        .withCurrentDate(start)","    XCTAssertTrue(spec.isSatisfiedBy(atStart.currentContext()))","","    \/\/ At end boundary","    let atEnd = MockContextProvider()","        .withCurrentDate(end)","    XCTAssertTrue(spec.isSatisfiedBy(atEnd.currentContext()))","}"]},{"level":2,"type":"heading","text":"Best Practices","anchor":"Best-Practices"},{"level":3,"type":"heading","text":"Use Specific Times for Precision","anchor":"Use-Specific-Times-for-Precision"},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Good - includes time components for exact boundaries","let start = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 1,","    hour: 0,","    minute: 0,","    second: 0",").date!","","let end = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 31,","    hour: 23,","    minute: 59,","    second: 59",").date!","","\/\/ ❌ Avoid - ambiguous time boundaries","let start = DateComponents(","    calendar: .current,","    year: 2025,","    month: 12,","    day: 1",").date!  \/\/ Defaults to midnight, but not explicit"]},{"level":3,"type":"heading","text":"Validate Date Order","anchor":"Validate-Date-Order"},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Good - validate that start is before end","func createDateRangeSpec(start: Date, end: Date) -> DateRangeSpec? {","    guard start < end else {","        print(\"Error: Start date must be before end date\")","        return nil","    }","    return DateRangeSpec(start: start, end: end)","}","","\/\/ ❌ Avoid - no validation","let spec = DateRangeSpec(start: endDate, end: startDate)  \/\/ Wrong order!"]},{"level":3,"type":"heading","text":"Consider Time Zones","anchor":"Consider-Time-Zones"},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Good - explicit time zone handling","var calendar = Calendar.current","calendar.timeZone = TimeZone(identifier: \"America\/New_York\")!","","let start = DateComponents(","    calendar: calendar,","    timeZone: TimeZone(identifier: \"America\/New_York\"),","    year: 2025,","    month: 12,","    day: 1",").date!","","\/\/ ❌ Avoid - assuming local time zone","let start = DateComponents(year: 2025, month: 12, day: 1).date!"]},{"level":2,"type":"heading","text":"Performance Considerations","anchor":"Performance-Considerations"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Simple Comparison"}],"type":"strong"},{"text":": Uses Date’s comparable implementation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"No Computation","type":"text"}],"type":"strong"},{"text":": No complex date arithmetic","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Inclusive Range","type":"text"}],"type":"strong"},{"type":"text","text":": Uses Swift’s ClosedRange operator"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Context Date"}],"type":"strong"},{"type":"text","text":": Uses pre-calculated currentDate from context"}],"type":"paragraph"}]}]}],"kind":"content"}],"topicSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/init(start:end:)"],"title":"Creating Specifications","anchor":"Creating-Specifications"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/isSatisfiedBy(_:)"],"generated":true,"title":"Instance Methods","anchor":"Instance-Methods"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/T"],"generated":true,"title":"Type Aliases","anchor":"Type-Aliases"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/Specification-Implementations"],"generated":true,"title":"Default Implementations","anchor":"Default-Implementations"}],"seeAlsoSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec"],"generated":true,"title":"Basic Specifications","anchor":"Basic-Specifications"}],"abstract":[{"type":"text","text":"Succeeds when "},{"type":"codeVoice","code":"currentDate"},{"type":"text","text":" is within the inclusive range [start, end]."}],"relationshipsSections":[{"type":"conformsTo","identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification"],"title":"Conforms To","kind":"relationships"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec"},"sections":[],"metadata":{"modules":[{"name":"SpecificationCore"}],"title":"DateRangeSpec","roleHeading":"Structure","externalID":"s:17SpecificationCore13DateRangeSpecV","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DateRangeSpec"}],"navigatorTitle":[{"text":"DateRangeSpec","kind":"identifier"}],"role":"symbol","symbolKind":"struct"},"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"kind":"symbol","variants":[{"paths":["\/documentation\/specificationcore\/daterangespec"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec/isSatisfiedBy(_:)":{"url":"\/documentation\/specificationcore\/daterangespec\/issatisfiedby(_:)","type":"topic","abstract":[{"text":"Evaluates whether the given context satisfies this specification.","type":"text"}],"title":"isSatisfiedBy(_:)","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"isSatisfiedBy"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"EvaluationContext","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/isSatisfiedBy(_:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec/T":{"navigatorTitle":[{"text":"T","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/daterangespec\/t","title":"DateRangeSpec.T","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/T","abstract":[{"text":"The type of context that this specification evaluates.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"T"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/TimeSinceEventSpec":{"url":"\/documentation\/specificationcore\/timesinceeventspec","abstract":[{"type":"text","text":"A specification that checks if a minimum duration has passed since a specific event."},{"type":"text","text":" "},{"text":"This is useful for implementing cooldown periods, delays, or time-based restrictions.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","role":"symbol","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"TimeSinceEventSpec"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TimeSinceEventSpec","kind":"identifier"}],"title":"TimeSinceEventSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec","url":"\/documentation\/specificationcore\/daterangespec","abstract":[{"text":"Succeeds when ","type":"text"},{"type":"codeVoice","code":"currentDate"},{"type":"text","text":" is within the inclusive range [start, end]."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"DateRangeSpec","kind":"identifier"}],"title":"DateRangeSpec","type":"topic","role":"symbol","navigatorTitle":[{"text":"DateRangeSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec":{"role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PredicateSpec","kind":"identifier"}],"abstract":[{"text":"A specification that accepts a closure for arbitrary logic.","type":"text"},{"text":" ","type":"text"},{"text":"This provides maximum flexibility for custom business rules that don’t fit","type":"text"},{"text":" ","type":"text"},{"text":"into the standard specification patterns.","type":"text"}],"type":"topic","url":"\/documentation\/specificationcore\/predicatespec","title":"PredicateSpec","navigatorTitle":[{"text":"PredicateSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec":{"type":"topic","navigatorTitle":[{"text":"DateComparisonSpec","kind":"identifier"}],"title":"DateComparisonSpec","url":"\/documentation\/specificationcore\/datecomparisonspec","kind":"symbol","abstract":[{"text":"Compares the date of a stored event to a reference date using before\/after.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DateComparisonSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/FirstMatchSpec":{"url":"\/documentation\/specificationcore\/firstmatchspec","type":"topic","navigatorTitle":[{"text":"FirstMatchSpec","kind":"identifier"}],"abstract":[{"text":"A decision specification that evaluates child specifications in order and returns","type":"text"},{"text":" ","type":"text"},{"text":"the result of the first one that is satisfied.","type":"text"}],"title":"FirstMatchSpec","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FirstMatchSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/CooldownIntervalSpec":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CooldownIntervalSpec"}],"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"A specification that ensures enough time has passed since the last occurrence of an event."},{"type":"text","text":" "},{"type":"text","text":"This is particularly useful for implementing cooldown periods for actions like showing banners,"},{"type":"text","text":" "},{"type":"text","text":"notifications, or any other time-sensitive operations that shouldn’t happen too frequently."}],"url":"\/documentation\/specificationcore\/cooldownintervalspec","title":"CooldownIntervalSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"CooldownIntervalSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec/init(start:end:)":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/init(start:end:)","kind":"symbol","abstract":[],"url":"\/documentation\/specificationcore\/daterangespec\/init(start:end:)","fragments":[{"kind":"identifier","text":"init"},{"text":"(","kind":"text"},{"text":"start","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Date","preciseIdentifier":"s:10Foundation4DateV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"end"},{"text":": ","kind":"text"},{"text":"Date","kind":"typeIdentifier","preciseIdentifier":"s:10Foundation4DateV"},{"text":")","kind":"text"}],"title":"init(start:end:)","type":"topic","role":"symbol"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec/Specification-Implementations":{"url":"\/documentation\/specificationcore\/daterangespec\/specification-implementations","abstract":[],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec\/Specification-Implementations","role":"collectionGroup","type":"topic","kind":"article","title":"Specification Implementations"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MaxCountSpec":{"navigatorTitle":[{"text":"MaxCountSpec","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/maxcountspec","title":"MaxCountSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","abstract":[{"type":"text","text":"A specification that checks if a counter is below a maximum threshold."},{"type":"text","text":" "},{"type":"text","text":"This is useful for implementing limits on actions, display counts, or usage restrictions."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxCountSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MockContextProvider":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MockContextProvider","kind":"symbol","type":"topic","abstract":[{"text":"A mock context provider designed for unit testing.","type":"text"},{"text":" ","type":"text"},{"text":"This provider allows you to set up specific context scenarios","type":"text"},{"text":" ","type":"text"},{"text":"and verify that specifications behave correctly under controlled conditions.","type":"text"}],"title":"MockContextProvider","navigatorTitle":[{"text":"MockContextProvider","kind":"identifier"}],"url":"\/documentation\/specificationcore\/mockcontextprovider","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MockContextProvider","kind":"identifier"}],"role":"symbol"}}}