{"primaryContentSections":[{"declarations":[{"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PredicateSpec","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"text":">","kind":"text"}],"languages":["swift"],"platforms":["macOS"]}],"kind":"declarations"},{"content":[{"anchor":"overview","text":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A specification that accepts a closure for arbitrary logic."}]},{"text":"Overview","type":"heading","level":2,"anchor":"Overview"},{"inlineContent":[{"type":"codeVoice","code":"PredicateSpec"},{"type":"text","text":" provides maximum flexibility for custom business rules that don’t fit into standard specification patterns. It allows you to create specifications from closures, KeyPath expressions, or use pre-built factory methods for common scenarios."}],"type":"paragraph"},{"text":"Key Benefits","type":"heading","level":3,"anchor":"Key-Benefits"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Flexible Creation","type":"text"}],"type":"strong"},{"text":": Create specs from closures, predicates, or KeyPath expressions","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Type Safety","type":"text"}]},{"type":"text","text":": Strongly-typed with generic context parameter"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Descriptive","type":"text"}]},{"text":": Optional description property for debugging and logging","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Composable"}],"type":"strong"},{"text":": Supports composition with other PredicateSpecs","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"EvaluationContext Helpers"}],"type":"strong"},{"text":": Specialized methods for context-based specs","type":"text"}],"type":"paragraph"}]}]},{"text":"When to Use PredicateSpec","type":"heading","level":3,"anchor":"When-to-Use-PredicateSpec"},{"inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"PredicateSpec"},{"text":" when you need to:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Create quick, inline specifications without defining new types","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Prototype specifications before extracting to dedicated types"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement simple one-off business rules"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use KeyPath-based property checks"}]}]},{"content":[{"inlineContent":[{"text":"Create context-aware predicates for feature flags and counters","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","anchor":"Quick-Example","level":2,"text":"Quick Example"},{"code":["import SpecificationCore","","struct User {","    let age: Int","    let email: String","    let isActive: Bool","}","","\/\/ Create from closure","let adultSpec = PredicateSpec<User>(description: \"Is adult\") { user in","    user.age >= 18","}","","\/\/ Create from KeyPath","let activeSpec = PredicateSpec.keyPath(\\.isActive, description: \"Is active\")","","\/\/ Create with property comparison","let premiumSpec = PredicateSpec.keyPath(","    \\.subscriptionTier,","    equals: \"premium\",","    description: \"Is premium user\"",")","","\/\/ Use like any specification","if adultSpec.isSatisfiedBy(user) {","    print(\"User is an adult\")","}"],"type":"codeListing","syntax":"swift"},{"text":"Creating from Closures","anchor":"Creating-from-Closures","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"The most flexible way to create predicate specifications:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Simple boolean predicate","let emailValid = PredicateSpec<User>(description: \"Valid email\") { user in","    user.email.contains(\"@\") && user.email.contains(\".\")","}","","\/\/ Multi-line logic","let eligibleForDiscount = PredicateSpec<User>(","    description: \"Eligible for discount\"",") { user in","    guard user.isActive else { return false }","    let daysSinceRegistration = user.daysSinceRegistration","    return daysSinceRegistration > 30 && user.purchaseCount < 5","}","","\/\/ No description (optional)","let quickCheck = PredicateSpec<User> { $0.age >= 21 }"]},{"text":"KeyPath-Based Specifications","anchor":"KeyPath-Based-Specifications","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create specifications from Swift KeyPaths:"}]},{"text":"Boolean KeyPath","anchor":"Boolean-KeyPath","type":"heading","level":3},{"type":"codeListing","code":["struct Account {","    let isVerified: Bool","    let isPremium: Bool","}","","\/\/ Check boolean property","let verifiedSpec = PredicateSpec.keyPath(\\.isVerified)","let premiumSpec = PredicateSpec.keyPath(\\.isPremium, description: \"Premium account\")","","let account = Account(isVerified: true, isPremium: false)","verifiedSpec.isSatisfiedBy(account)  \/\/ true"],"syntax":"swift"},{"text":"Equality Checks","type":"heading","anchor":"Equality-Checks","level":3},{"code":["struct Order {","    let status: String","    let priority: Int","}","","\/\/ Check for specific value","let completedSpec = PredicateSpec.keyPath(","    \\.status,","    equals: \"completed\"",")","","let highPrioritySpec = PredicateSpec.keyPath(","    \\.priority,","    equals: 1,","    description: \"High priority\"",")","","let order = Order(status: \"completed\", priority: 1)","completedSpec.isSatisfiedBy(order)  \/\/ true"],"type":"codeListing","syntax":"swift"},{"text":"Comparison Operations","type":"heading","anchor":"Comparison-Operations","level":3},{"type":"codeListing","syntax":"swift","code":["struct Product {","    let price: Decimal","    let stock: Int","    let rating: Double","}","","\/\/ Greater than","let expensiveSpec = PredicateSpec.keyPath(","    \\.price,","    greaterThan: 100.0",")","","\/\/ Less than","let lowStockSpec = PredicateSpec.keyPath(","    \\.stock,","    lessThan: 10",")","","\/\/ Range check","let ratedSpec = PredicateSpec.keyPath(","    \\.rating,","    in: 4.0...5.0,","    description: \"Highly rated\"",")"]},{"anchor":"EvaluationContext-Specifications","text":"EvaluationContext Specifications","type":"heading","level":2},{"inlineContent":[{"text":"Specialized factory methods for working with ","type":"text"},{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","isActive":true,"type":"reference"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"text":"Flag Checking","anchor":"Flag-Checking"},{"type":"codeListing","syntax":"swift","code":["\/\/ Check if flag is true","let premiumEnabled = PredicateSpec.flag(\"premium_features\")","","\/\/ Check for specific value","let betaDisabled = PredicateSpec.flag(\"beta_mode\", equals: false)","","\/\/ With description","let analyticsSpec = PredicateSpec.flag(","    \"analytics_enabled\",","    equals: true,","    description: \"Analytics enabled\"",")","","let context = EvaluationContext(flags: [\"premium_features\": true])","premiumEnabled.isSatisfiedBy(context)  \/\/ true"]},{"anchor":"Counter-Checking","text":"Counter Checking","type":"heading","level":3},{"code":["\/\/ Check counter value with comparison","let withinLimit = PredicateSpec.counter(","    \"api_calls\",","    .lessThan,","    100",")","","let exactCount = PredicateSpec.counter(","    \"login_attempts\",","    .equal,","    3,","    description: \"Exactly 3 attempts\"",")","","let highUsage = PredicateSpec.counter(","    \"daily_requests\",","    .greaterThanOrEqual,","    1000",")","","\/\/ Available comparisons: .lessThan, .lessThanOrEqual, .equal,","\/\/ .greaterThanOrEqual, .greaterThan, .notEqual"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Event-Checking","text":"Event Checking","type":"heading"},{"syntax":"swift","code":["\/\/ Check if event exists","let hasLoggedIn = PredicateSpec.eventExists(\"last_login\")","","let hasCompletedTutorial = PredicateSpec.eventExists(","    \"tutorial_completed\",","    description: \"Tutorial completed\"",")","","let context = EvaluationContext(","    events: [\"last_login\": Date()]",")","hasLoggedIn.isSatisfiedBy(context)  \/\/ true"],"type":"codeListing"},{"text":"Time-Based Specifications","anchor":"Time-Based-Specifications","level":3,"type":"heading"},{"syntax":"swift","code":["\/\/ Check time since launch","let runningSufficiently = PredicateSpec.timeSinceLaunch(","    greaterThan: 60  \/\/ 1 minute",")","","\/\/ Check current hour","let businessHours = PredicateSpec.currentHour(in: 9...17)","","let lateNight = PredicateSpec.currentHour(","    in: 22...6,  \/\/ Wraps around midnight","    description: \"Late night hours\"",")","","\/\/ Weekday\/weekend checks","let isWeekday = PredicateSpec.isWeekday()","let isWeekend = PredicateSpec.isWeekend(description: \"Weekend\")"],"type":"codeListing"},{"level":2,"text":"Constant Specifications","type":"heading","anchor":"Constant-Specifications"},{"inlineContent":[{"type":"text","text":"Pre-built specifications for edge cases:"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Always returns true","let alwaysTrue = PredicateSpec<User>.alwaysTrue()","","\/\/ Always returns false","let alwaysFalse = PredicateSpec<User>.alwaysFalse()","","\/\/ Useful for conditional logic","let spec = isMaintenanceMode","    ? PredicateSpec<User>.alwaysFalse()","    : ActualEligibilitySpec()"],"type":"codeListing"},{"level":2,"text":"Composition","type":"heading","anchor":"Composition"},{"inlineContent":[{"type":"text","text":"Combine PredicateSpecs with logical operators:"}],"type":"paragraph"},{"level":3,"anchor":"AND-Composition","type":"heading","text":"AND Composition"},{"type":"codeListing","syntax":"swift","code":["let adult = PredicateSpec<User> { $0.age >= 18 }","let active = PredicateSpec<User> { $0.isActive }","","\/\/ Combine with AND","let eligible = adult.and(active)","","\/\/ Description is combined","print(eligible.description)  \/\/ \"Is adult AND Is active\""]},{"level":3,"anchor":"OR-Composition","text":"OR Composition","type":"heading"},{"syntax":"swift","type":"codeListing","code":["let premium = PredicateSpec<User> { $0.tier == \"premium\" }","let trial = PredicateSpec<User> { $0.tier == \"trial\" }","","\/\/ Combine with OR","let hasAccess = premium.or(trial)"]},{"level":3,"type":"heading","anchor":"NOT-Composition","text":"NOT Composition"},{"type":"codeListing","syntax":"swift","code":["let banned = PredicateSpec<User> { $0.isBanned }","","\/\/ Negate","let notBanned = banned.not()","","print(notBanned.description)  \/\/ \"NOT (Is banned)\""]},{"anchor":"Complex-Composition","text":"Complex Composition","type":"heading","level":3},{"code":["let adultSpec = PredicateSpec<User>(description: \"Adult\") { $0.age >= 18 }","let activeSpec = PredicateSpec<User>(description: \"Active\") { $0.isActive }","let bannedSpec = PredicateSpec<User>(description: \"Banned\") { $0.isBanned }","","\/\/ (Adult AND Active) AND NOT Banned","let eligible = adultSpec","    .and(activeSpec)","    .and(bannedSpec.not())"],"type":"codeListing","syntax":"swift"},{"text":"Contramap Transformation","type":"heading","anchor":"Contramap-Transformation","level":2},{"type":"paragraph","inlineContent":[{"text":"Transform the input type of a predicate:","type":"text"}]},{"code":["struct User {","    let profile: UserProfile","}","","struct UserProfile {","    let age: Int","}","","\/\/ Spec for UserProfile","let adultProfileSpec = PredicateSpec<UserProfile> { $0.age >= 18 }","","\/\/ Transform to work with User","let adultUserSpec = adultProfileSpec.contramap { (user: User) in","    user.profile","}","","let user = User(profile: UserProfile(age: 25))","adultUserSpec.isSatisfiedBy(user)  \/\/ true"],"type":"codeListing","syntax":"swift"},{"text":"Collection Extensions","type":"heading","anchor":"Collection-Extensions","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create specifications from collections of specifications:"}]},{"type":"codeListing","code":["let validations: [PredicateSpec<User>] = [","    PredicateSpec { $0.email.contains(\"@\") },","    PredicateSpec { $0.age >= 18 },","    PredicateSpec { $0.isActive }","]","","\/\/ All must be satisfied (AND)","let allValid = validations.allSatisfiedPredicate()","","\/\/ Any can be satisfied (OR)","let anyValid = validations.anySatisfiedPredicate()"],"syntax":"swift"},{"level":2,"text":"Debugging with Descriptions","anchor":"Debugging-with-Descriptions","type":"heading"},{"inlineContent":[{"text":"Use descriptions for logging and debugging:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let spec = PredicateSpec<User>(description: \"Premium user check\") { user in","    user.subscriptionTier == \"premium\" && user.isActive","}","","\/\/ Access description","print(\"Evaluating: \\(spec.description ?? \"unnamed spec\")\")","","\/\/ Useful in logs","func evaluate(user: User, with spec: PredicateSpec<User>) -> Bool {","    let result = spec.isSatisfiedBy(user)","    print(\"[\\(spec.description ?? \"spec\")] = \\(result)\")","    return result","}"],"syntax":"swift"},{"level":2,"text":"Real-World Examples","anchor":"Real-World-Examples","type":"heading"},{"level":3,"text":"Form Validation","anchor":"Form-Validation","type":"heading"},{"type":"codeListing","code":["struct RegistrationForm {","    let email: String","    let password: String","    let age: Int","    let agreedToTerms: Bool","}","","let validEmail = PredicateSpec<RegistrationForm>(","    description: \"Valid email\"",") { form in","    let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"","    return NSPredicate(format: \"SELF MATCHES %@\", emailRegex)","        .evaluate(with: form.email)","}","","let strongPassword = PredicateSpec<RegistrationForm>(","    description: \"Strong password\"",") { form in","    form.password.count >= 8 &&","    form.password.rangeOfCharacter(from: .uppercaseLetters) != nil &&","    form.password.rangeOfCharacter(from: .decimalDigits) != nil","}","","let legalAge = PredicateSpec.keyPath(","    \\RegistrationForm.age,","    greaterThanOrEqual: 18,","    description: \"Legal age\"",")","","let termsAccepted = PredicateSpec.keyPath(","    \\.agreedToTerms,","    description: \"Terms accepted\"",")","","\/\/ Combine all validations","let formValid = validEmail","    .and(strongPassword)","    .and(legalAge)","    .and(termsAccepted)"],"syntax":"swift"},{"level":3,"text":"Feature Access Control","anchor":"Feature-Access-Control","type":"heading"},{"type":"codeListing","code":["\/\/ Context-based feature access","let canAccessPremiumFeatures = PredicateSpec<EvaluationContext>(","    description: \"Premium feature access\"",") { context in","    let isPremium = context.flag(for: \"is_premium\")","    let withinLimit = context.counter(for: \"monthly_usage\") < 1000","    let notOnCooldown = context.timeSinceEvent(\"last_feature_use\")","        .map { $0 > 3600 } ?? true","","    return isPremium && withinLimit && notOnCooldown","}"],"syntax":"swift"},{"level":3,"text":"Business Hours Check","anchor":"Business-Hours-Check","type":"heading"},{"type":"codeListing","code":["let isDuringBusinessHours = PredicateSpec<EvaluationContext>(","    description: \"Business hours\"",") { context in","    let calendar = context.calendar","    let components = calendar.dateComponents(","        [.hour, .weekday],","        from: context.currentDate","    )","","    guard let hour = components.hour,","          let weekday = components.weekday else {","        return false","    }","","    let isWeekday = (2...6).contains(weekday)  \/\/ Mon-Fri","    let isBusinessHours = (9...17).contains(hour)  \/\/ 9 AM - 5 PM","","    return isWeekday && isBusinessHours","}"],"syntax":"swift"},{"level":2,"text":"Best Practices","anchor":"Best-Practices","type":"heading"},{"level":3,"text":"Provide Descriptions","anchor":"Provide-Descriptions","type":"heading"},{"type":"codeListing","code":["\/\/ ✅ Good - descriptive for debugging","let spec = PredicateSpec<User>(description: \"Active premium user\") { user in","    user.isActive && user.tier == \"premium\"","}","","\/\/ ❌ Less useful - no description","let spec = PredicateSpec<User> { user in","    user.isActive && user.tier == \"premium\"","}"],"syntax":"swift"},{"level":3,"text":"Keep Predicates Focused","anchor":"Keep-Predicates-Focused","type":"heading"},{"type":"codeListing","code":["\/\/ ✅ Good - single responsibility","let adultSpec = PredicateSpec<User>(description: \"Adult\") { $0.age >= 18 }","let activeSpec = PredicateSpec<User>(description: \"Active\") { $0.isActive }","let eligible = adultSpec.and(activeSpec)","","\/\/ ❌ Avoid - mixed concerns in one predicate","let spec = PredicateSpec<User> { user in","    user.age >= 18 && user.isActive && user.email.contains(\"@\")","}"],"syntax":"swift"},{"level":3,"text":"Use KeyPath Methods When Possible","anchor":"Use-KeyPath-Methods-When-Possible","type":"heading"},{"type":"codeListing","code":["\/\/ ✅ Good - concise with KeyPath","let activeSpec = PredicateSpec.keyPath(\\.isActive)","","\/\/ ❌ Verbose - unnecessary closure","let activeSpec = PredicateSpec<User> { user in","    user.isActive","}"],"syntax":"swift"},{"level":3,"text":"Extract Complex Logic","anchor":"Extract-Complex-Logic","type":"heading"},{"type":"codeListing","code":["\/\/ ✅ Good - extract to named function","func isEligibleForRefund(_ order: Order) -> Bool {","    let daysSincePurchase = Date().timeIntervalSince(order.purchaseDate) \/ 86400","    return daysSincePurchase <= 30 && !order.isRefunded","}","","let refundEligible = PredicateSpec<Order>(","    description: \"Refund eligible\",","    isEligibleForRefund",")","","\/\/ ❌ Harder to read - complex inline logic","let refundEligible = PredicateSpec<Order> { order in","    let daysSincePurchase = Date().timeIntervalSince(order.purchaseDate) \/ 86400","    return daysSincePurchase <= 30 && !order.isRefunded","}"],"syntax":"swift"},{"level":2,"text":"Performance Considerations","anchor":"Performance-Considerations","type":"heading"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Closure Overhead","type":"text"}]},{"text":": Minimal overhead; closures are stored and called directly","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"KeyPath Performance"}],"type":"strong"},{"type":"text","text":": KeyPath access is optimized by Swift runtime"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Description Storage","type":"text"}],"type":"strong"},{"text":": Optional string has minimal memory impact","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Composition","type":"text"}],"type":"strong"},{"type":"text","text":": Each composition creates a new PredicateSpec; efficient for short chains"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Collection Methods"}]},{"type":"text","text":": "},{"type":"codeVoice","code":"allSatisfiedPredicate()"},{"type":"text","text":" short-circuits on first failure"}],"type":"paragraph"}]}]}],"kind":"content"}],"kind":"symbol","topicSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/init(description:_:)"],"title":"Creating Specifications","anchor":"Creating-Specifications"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/alwaysTrue()","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/alwaysFalse()"],"title":"Constant Specifications","anchor":"Constant-Specifications"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:equals:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:greaterThan:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:lessThan:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:in:description:)"],"title":"KeyPath-Based Creation","anchor":"KeyPath-Based-Creation"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/flag(_:equals:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/counter(_:_:_:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/eventExists(_:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/timeSinceLaunch(greaterThan:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/currentHour(in:description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isWeekday(description:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isWeekend(description:)"],"title":"EvaluationContext Helpers","anchor":"EvaluationContext-Helpers"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/and(_:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/or(_:)","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/not()","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/contramap(_:)"],"title":"Composition","anchor":"Composition"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/description"],"title":"Properties","anchor":"Properties"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CounterComparison"],"title":"Supporting Types","anchor":"Supporting-Types"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isSatisfiedBy(_:)"],"generated":true,"title":"Instance Methods","anchor":"Instance-Methods"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/Specification-Implementations"],"generated":true,"title":"Default Implementations","anchor":"Default-Implementations"}],"seeAlsoSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec","doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec"],"generated":true,"title":"Basic Specifications","anchor":"Basic-Specifications"}],"abstract":[{"type":"text","text":"A specification that accepts a closure for arbitrary logic."},{"type":"text","text":" "},{"type":"text","text":"This provides maximum flexibility for custom business rules that don’t fit"},{"type":"text","text":" "},{"type":"text","text":"into the standard specification patterns."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec"},"metadata":{"roleHeading":"Structure","symbolKind":"struct","title":"PredicateSpec","modules":[{"name":"SpecificationCore"}],"navigatorTitle":[{"text":"PredicateSpec","kind":"identifier"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PredicateSpec","kind":"identifier"}],"externalID":"s:17SpecificationCore13PredicateSpecV"},"sections":[],"variants":[{"paths":["\/documentation\/specificationcore\/predicatespec"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore"]]},"relationshipsSections":[{"identifiers":["doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification"],"type":"conformsTo","kind":"relationships","title":"Conforms To"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"references":{"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/isWeekday(description:)":{"type":"topic","title":"isWeekday(description:)","url":"\/documentation\/specificationcore\/predicatespec\/isweekday(description:)","kind":"symbol","abstract":[{"type":"text","text":"Creates a predicate that checks if it’s currently a weekday"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isWeekday(description:)","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"isWeekday","kind":"identifier"},{"text":"(","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"text":"<","kind":"text"},{"text":"EvaluationContext","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV"},{"text":">","kind":"text"}],"conformance":{"constraints":[{"type":"codeVoice","code":"T"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"EvaluationContext"},{"text":".","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/flag(_:equals:description:)":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/flag(_:equals:description:)","title":"flag(_:equals:description:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/flag(_:equals:description:)","abstract":[{"text":"Creates a predicate that checks if a flag is set","type":"text"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"T","type":"codeVoice"},{"type":"text","text":" is "},{"code":"EvaluationContext","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"flag","kind":"identifier"},{"text":"(","kind":"text"},{"text":"String","preciseIdentifier":"s:SS","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"equals","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","preciseIdentifier":"s:SS","kind":"typeIdentifier"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"EvaluationContext","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV","kind":"typeIdentifier"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/alwaysFalse()":{"type":"topic","title":"alwaysFalse()","url":"\/documentation\/specificationcore\/predicatespec\/alwaysfalse()","kind":"symbol","abstract":[{"type":"text","text":"Creates a predicate specification that always returns false"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/alwaysFalse()","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"alwaysFalse","kind":"identifier"},{"text":"() -> ","kind":"text"},{"text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/counter(_:_:_:description:)":{"url":"\/documentation\/specificationcore\/predicatespec\/counter(_:_:_:description:)","type":"topic","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"T","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"EvaluationContext","type":"codeVoice"},{"text":".","type":"text"}]},"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/counter(_:_:_:description:)","role":"symbol","title":"counter(_:_:_:description:)","abstract":[{"text":"Creates a predicate that checks a counter value","type":"text"}],"kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"counter","kind":"identifier"},{"text":"(","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":", ","kind":"text"},{"text":"CounterComparison","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore17CounterComparisonO"},{"text":", ","kind":"text"},{"text":"Int","kind":"typeIdentifier","preciseIdentifier":"s:Si"},{"text":", ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"text":"<","kind":"text"},{"text":"EvaluationContext","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore","title":"SpecificationCore","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore","abstract":[{"type":"text","text":"Platform-independent core for building specification-based business logic in Swift."}],"role":"collection"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/description":{"title":"description","kind":"symbol","type":"topic","abstract":[{"text":"An optional description of what this predicate checks","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/description","role":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/description","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"text":"description","kind":"identifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:SS","text":"String","kind":"typeIdentifier"},{"text":"?","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/isSatisfiedBy(_:)":{"url":"\/documentation\/specificationcore\/predicatespec\/issatisfiedby(_:)","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isSatisfiedBy(_:)","role":"symbol","title":"isSatisfiedBy(_:)","abstract":[{"text":"Evaluates whether the given context satisfies this specification.","type":"text"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"isSatisfiedBy"},{"text":"(","kind":"text"},{"text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/TimeSinceEventSpec":{"url":"\/documentation\/specificationcore\/timesinceeventspec","abstract":[{"type":"text","text":"A specification that checks if a minimum duration has passed since a specific event."},{"type":"text","text":" "},{"text":"This is useful for implementing cooldown periods, delays, or time-based restrictions.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/TimeSinceEventSpec","role":"symbol","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"TimeSinceEventSpec"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TimeSinceEventSpec","kind":"identifier"}],"title":"TimeSinceEventSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/timeSinceLaunch(greaterThan:description:)":{"url":"\/documentation\/specificationcore\/predicatespec\/timesincelaunch(greaterthan:description:)","abstract":[{"type":"text","text":"Creates a predicate that checks if enough time has passed since launch"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/timeSinceLaunch(greaterThan:description:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"timeSinceLaunch","kind":"identifier"},{"text":"(","kind":"text"},{"text":"greaterThan","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"c:@T@NSTimeInterval","text":"TimeInterval","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"description","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"?) -> "},{"kind":"typeIdentifier","text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"EvaluationContext","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV"},{"kind":"text","text":">"}],"conformance":{"constraints":[{"code":"T","type":"codeVoice"},{"type":"text","text":" is "},{"code":"EvaluationContext","type":"codeVoice"},{"text":".","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"title":"timeSinceLaunch(greaterThan:description:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/keyPath(_:description:)":{"url":"\/documentation\/specificationcore\/predicatespec\/keypath(_:description:)","abstract":[{"type":"text","text":"Creates a predicate specification from a KeyPath that returns a Bool"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:description:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"keyPath"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:s7KeyPathC","kind":"typeIdentifier","text":"KeyPath"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier","text":"T"},{"kind":"text","text":", "},{"preciseIdentifier":"s:Sb","kind":"typeIdentifier","text":"Bool"},{"kind":"text","text":">, "},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:SS","text":"String","kind":"typeIdentifier"},{"text":"?) -> ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T","kind":"typeIdentifier"},{"text":">","kind":"text"}],"title":"keyPath(_:description:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec":{"role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PredicateSpec","kind":"identifier"}],"abstract":[{"text":"A specification that accepts a closure for arbitrary logic.","type":"text"},{"text":" ","type":"text"},{"text":"This provides maximum flexibility for custom business rules that don’t fit","type":"text"},{"text":" ","type":"text"},{"text":"into the standard specification patterns.","type":"text"}],"type":"topic","url":"\/documentation\/specificationcore\/predicatespec","title":"PredicateSpec","navigatorTitle":[{"text":"PredicateSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateRangeSpec":{"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateRangeSpec","url":"\/documentation\/specificationcore\/daterangespec","abstract":[{"text":"Succeeds when ","type":"text"},{"type":"codeVoice","code":"currentDate"},{"type":"text","text":" is within the inclusive range [start, end]."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"DateRangeSpec","kind":"identifier"}],"title":"DateRangeSpec","type":"topic","role":"symbol","navigatorTitle":[{"text":"DateRangeSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/or(_:)":{"role":"symbol","title":"or(_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/or(_:)","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/or(_:)","type":"topic","abstract":[{"type":"text","text":"Combines this predicate with another using logical OR"}],"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"or"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier","text":"T"},{"kind":"text","text":">"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/keyPath(_:equals:description:)":{"role":"symbol","title":"keyPath(_:equals:description:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:equals:description:)","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/keypath(_:equals:description:)","type":"topic","abstract":[{"type":"text","text":"Creates a predicate specification that checks if a property equals a value"}],"fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"keyPath"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","preciseIdentifier":"s:s7KeyPathC","text":"KeyPath"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T"},{"kind":"text","text":", "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_6equals11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSQRd__lFZ5ValueL_qd__mfp","text":"Value"},{"kind":"text","text":">, "},{"kind":"externalParam","text":"equals"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_6equals11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSQRd__lFZ5ValueL_qd__mfp","text":"Value"},{"kind":"text","text":", "},{"kind":"externalParam","text":"description"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"kind":"text","text":"?) -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T"},{"kind":"text","text":">"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/and(_:)":{"url":"\/documentation\/specificationcore\/predicatespec\/and(_:)","abstract":[{"type":"text","text":"Combines this predicate with another using logical AND"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/and(_:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"and"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier","text":"PredicateSpec"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier","text":"T"},{"kind":"text","text":">) -> "},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier","text":"PredicateSpec"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T","kind":"typeIdentifier"},{"kind":"text","text":">"}],"title":"and(_:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/FirstMatchSpec":{"url":"\/documentation\/specificationcore\/firstmatchspec","type":"topic","navigatorTitle":[{"text":"FirstMatchSpec","kind":"identifier"}],"abstract":[{"text":"A decision specification that evaluates child specifications in order and returns","type":"text"},{"text":" ","type":"text"},{"text":"the result of the first one that is satisfied.","type":"text"}],"title":"FirstMatchSpec","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FirstMatchSpec","kind":"identifier"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/FirstMatchSpec"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/EvaluationContext":{"navigatorTitle":[{"text":"EvaluationContext","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/evaluationcontext","title":"EvaluationContext","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/EvaluationContext","abstract":[{"type":"text","text":"A context object that holds data needed for specification evaluation."},{"type":"text","text":" "},{"text":"This serves as a container for all the information that specifications might need","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make their decisions, such as timestamps, counters, user state, etc."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EvaluationContext","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/Specification-Implementations":{"type":"topic","kind":"article","url":"\/documentation\/specificationcore\/predicatespec\/specification-implementations","title":"Specification Implementations","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/Specification-Implementations","abstract":[],"role":"collectionGroup"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/keyPath(_:greaterThan:description:)":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/keypath(_:greaterthan:description:)","title":"keyPath(_:greaterThan:description:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:greaterThan:description:)","abstract":[{"text":"Creates a predicate specification that checks if a comparable property is greater than a value","type":"text"}],"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"keyPath"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"text":">(","kind":"text"},{"preciseIdentifier":"s:s7KeyPathC","text":"KeyPath","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Value","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_11greaterThan11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSLRd__lFZ5ValueL_qd__mfp","kind":"typeIdentifier"},{"text":">, ","kind":"text"},{"text":"greaterThan","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_11greaterThan11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSLRd__lFZ5ValueL_qd__mfp"},{"text":", ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":"?) -> ","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T","kind":"typeIdentifier"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/eventExists(_:description:)":{"type":"topic","title":"eventExists(_:description:)","url":"\/documentation\/specificationcore\/predicatespec\/eventexists(_:description:)","kind":"symbol","abstract":[{"type":"text","text":"Creates a predicate that checks if an event exists"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/eventExists(_:description:)","role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"eventExists"},{"kind":"text","text":"("},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"kind":"text","text":", "},{"kind":"externalParam","text":"description"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"kind":"text","text":"?) -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV","text":"EvaluationContext"},{"kind":"text","text":">"}],"conformance":{"constraints":[{"code":"T","type":"codeVoice"},{"type":"text","text":" is "},{"code":"EvaluationContext","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]}},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/keyPath(_:in:description:)":{"role":"symbol","kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"keyPath","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Value","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"KeyPath","kind":"typeIdentifier","preciseIdentifier":"s:s7KeyPathC"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"text":", ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_2in11descriptionACyxGs03KeyF0Cyxqd__G_SNyqd__GSSSgtSLRd__lFZ5ValueL_qd__mfp"},{"text":">, ","kind":"text"},{"text":"in","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ClosedRange","kind":"typeIdentifier","preciseIdentifier":"s:SN"},{"text":"<","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_2in11descriptionACyxGs03KeyF0Cyxqd__G_SNyqd__GSSSgtSLRd__lFZ5ValueL_qd__mfp"},{"text":">, ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"text":">","kind":"text"}],"title":"keyPath(_:in:description:)","type":"topic","url":"\/documentation\/specificationcore\/predicatespec\/keypath(_:in:description:)","abstract":[{"type":"text","text":"Creates a predicate specification that checks if a comparable property is within a range"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:in:description:)"},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/alwaysTrue()":{"type":"topic","title":"alwaysTrue()","url":"\/documentation\/specificationcore\/predicatespec\/alwaystrue()","kind":"symbol","abstract":[{"type":"text","text":"Creates a predicate specification that always returns true"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/alwaysTrue()","role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"alwaysTrue"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T"},{"kind":"text","text":">"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/CounterComparison":{"url":"\/documentation\/specificationcore\/countercomparison","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CounterComparison","role":"symbol","title":"CounterComparison","abstract":[{"text":"Enumeration of comparison operations for counter values","type":"text"}],"navigatorTitle":[{"text":"CounterComparison","kind":"identifier"}],"kind":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CounterComparison"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/keyPath(_:lessThan:description:)":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/keypath(_:lessthan:description:)","title":"keyPath(_:lessThan:description:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/keyPath(_:lessThan:description:)","abstract":[{"text":"Creates a predicate specification that checks if a comparable property is less than a value","type":"text"}],"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"keyPath","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Value","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"KeyPath","kind":"typeIdentifier","preciseIdentifier":"s:s7KeyPathC"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"text":", ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_8lessThan11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSLRd__lFZ5ValueL_qd__mfp"},{"text":">, ","kind":"text"},{"text":"lessThan","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV7keyPath_8lessThan11descriptionACyxGs03KeyF0Cyxqd__G_qd__SSSgtSLRd__lFZ5ValueL_qd__mfp"},{"text":", ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"text":">","kind":"text"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/Specification":{"url":"\/documentation\/specificationcore\/specification","type":"topic","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/Specification","role":"symbol","title":"Specification","abstract":[{"text":"A specification that evaluates whether a context satisfies certain conditions.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Specification"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Specification"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/currentHour(in:description:)":{"type":"topic","title":"currentHour(in:description:)","url":"\/documentation\/specificationcore\/predicatespec\/currenthour(in:description:)","kind":"symbol","abstract":[{"text":"Creates a predicate that checks the current time against a specific hour range","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/currentHour(in:description:)","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"currentHour","kind":"identifier"},{"text":"(","kind":"text"},{"text":"in","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ClosedRange","preciseIdentifier":"s:SN","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"},{"text":">, ","kind":"text"},{"text":"description","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"String","preciseIdentifier":"s:SS","kind":"typeIdentifier"},{"text":"?) -> ","kind":"text"},{"text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"EvaluationContext","preciseIdentifier":"s:17SpecificationCore17EvaluationContextV","kind":"typeIdentifier"},{"text":">","kind":"text"}],"conformance":{"constraints":[{"type":"codeVoice","code":"T"},{"type":"text","text":" is "},{"type":"codeVoice","code":"EvaluationContext"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]}},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/not()":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/not()","title":"not()","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/not()","abstract":[{"type":"text","text":"Negates this predicate specification"}],"role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"not"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","text":"PredicateSpec"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp","text":"T"},{"kind":"text","text":">"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/DateComparisonSpec":{"type":"topic","navigatorTitle":[{"text":"DateComparisonSpec","kind":"identifier"}],"title":"DateComparisonSpec","url":"\/documentation\/specificationcore\/datecomparisonspec","kind":"symbol","abstract":[{"text":"Compares the date of a stored event to a reference date using before\/after.","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/DateComparisonSpec","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DateComparisonSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/MaxCountSpec":{"navigatorTitle":[{"text":"MaxCountSpec","kind":"identifier"}],"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/maxcountspec","title":"MaxCountSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/MaxCountSpec","abstract":[{"type":"text","text":"A specification that checks if a counter is below a maximum threshold."},{"type":"text","text":" "},{"type":"text","text":"This is useful for implementing limits on actions, display counts, or usage restrictions."}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxCountSpec","kind":"identifier"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/isWeekend(description:)":{"type":"topic","title":"isWeekend(description:)","url":"\/documentation\/specificationcore\/predicatespec\/isweekend(description:)","kind":"symbol","abstract":[{"text":"Creates a predicate that checks if it’s currently a weekend","type":"text"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/isWeekend(description:)","role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"isWeekend"},{"kind":"text","text":"("},{"kind":"externalParam","text":"description"},{"kind":"text","text":": "},{"preciseIdentifier":"s:SS","kind":"typeIdentifier","text":"String"},{"kind":"text","text":"?) -> "},{"preciseIdentifier":"s:17SpecificationCore13PredicateSpecV","kind":"typeIdentifier","text":"PredicateSpec"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:17SpecificationCore17EvaluationContextV","kind":"typeIdentifier","text":"EvaluationContext"},{"kind":"text","text":">"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"constraints":[{"code":"T","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"EvaluationContext","type":"codeVoice"},{"text":".","type":"text"}]}},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/init(description:_:)":{"type":"topic","kind":"symbol","url":"\/documentation\/specificationcore\/predicatespec\/init(description:_:)","title":"init(description:_:)","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/init(description:_:)","abstract":[{"type":"text","text":"Creates a new PredicateSpec with the given predicate"}],"role":"symbol","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"description"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"?, ("},{"kind":"typeIdentifier","text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":")"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/CooldownIntervalSpec":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CooldownIntervalSpec"}],"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"A specification that ensures enough time has passed since the last occurrence of an event."},{"type":"text","text":" "},{"type":"text","text":"This is particularly useful for implementing cooldown periods for actions like showing banners,"},{"type":"text","text":" "},{"type":"text","text":"notifications, or any other time-sensitive operations that shouldn’t happen too frequently."}],"url":"\/documentation\/specificationcore\/cooldownintervalspec","title":"CooldownIntervalSpec","identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/CooldownIntervalSpec","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"CooldownIntervalSpec"}]},"doc://specificationcore.SpecificationCore/documentation/SpecificationCore/PredicateSpec/contramap(_:)":{"type":"topic","title":"contramap(_:)","url":"\/documentation\/specificationcore\/predicatespec\/contramap(_:)","kind":"symbol","abstract":[{"type":"text","text":"Maps the input type of the predicate specification using a transform function"}],"identifier":"doc:\/\/specificationcore.SpecificationCore\/documentation\/SpecificationCore\/PredicateSpec\/contramap(_:)","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"contramap"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"U"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"U","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV9contramapyACyqd__Gxqd__clF1UL_qd__mfp"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"T","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV1Txmfp"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"PredicateSpec","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"U","preciseIdentifier":"s:17SpecificationCore13PredicateSpecV9contramapyACyqd__Gxqd__clF1UL_qd__mfp"},{"kind":"text","text":">"}]}}}