# @AutoContext Macro

## Article Metadata
- **Identifier:** doc://specificationcore.SpecificationCore/documentation/SpecificationCore/AutoContextMacro
- **Article Kind:** article
- **Catalog Identifier:** doc://specificationcore.SpecificationCore/documentation/SpecificationCore
- **Catalog Title:** SpecificationCore
- **Catalog Kind:** symbol
- **Catalog Role:** collection
- **Section Count:** 31
- **Reference Count:** 1

## Abstract
A macro that automatically provides context provider conformance and enables convenient async specification evaluation.

## Sections

### Overview
- The `@AutoContext` macro eliminates boilerplate by automatically injecting the necessary code for specifications to work with [DefaultContextProvider](/documentation/specificationcore/defaultcontextprovider). It adds conformance to `AutoContextSpecification`, provides a context provider property, and when combined with `specs`, adds an `isSatisfied` computed property for convenient async evaluation.

### Key Benefits
- Eliminates Boilerplate: No manual context provider wiring needed
- Auto-Conformance: Automatically conforms to `AutoContextSpecification`
- Convenience Property: Adds `isSatisfied` async property when used with `specs`
- Default Provider: Uses `DefaultContextProvider.shared` automatically
- Type-Safe: Compile-time type checking for context providers
- Future-Proof: Designed to support custom providers in future versions

### When to Use @AutoContext
- Use `@AutoContext` when you need to:
- Create specifications that work with the default context provider
- Enable convenient async evaluation without explicit provider passing
- Reduce boilerplate in specification definitions
- Build reusable specification types that automatically have provider access
- Combine with `specs` macro for maximum convenience

### Quick Example
```swift
import SpecificationCore

// Without @AutoContext - manual provider management
struct PremiumUserSpec: Specification {
    typealias T = EvaluationContext

    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {
        return candidate.flag(for: "premium_subscription")
    }

    // Manual usage requires provider
    static func evaluate() -> Bool {
        let context = DefaultContextProvider.shared.currentContext()
        return Self().isSatisfiedBy(context)
    }
}

// With @AutoContext - automatic provider access
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "premium_subscription")
)
struct PremiumUserSpec: Specification {
    typealias T = EvaluationContext
}

// Convenient async evaluation
if try await PremiumUserSpec().isSatisfied {
    enablePremiumFeatures()
}
```

### How @AutoContext Works
- The macro generates provider-related boilerplate automatically:
```swift
@AutoContext
struct MySpec: Specification {
    typealias T = EvaluationContext
    // Your specification logic...
}

// Expands to add:
struct MySpec: Specification {
    typealias T = EvaluationContext

    // Generated by @AutoContext:
    public typealias Provider = DefaultContextProvider
    public static var contextProvider: DefaultContextProvider {
        DefaultContextProvider.shared
    }

    // Your specification logic...
}
```
- When combined with `specs`, it also adds:
```swift
@AutoContext
@specs(SomeSpec())
struct MySpec: Specification {
    typealias T = EvaluationContext
}

// Also generates:
public var isSatisfied: Bool {
    get async throws {
        let ctx = try await Self.contextProvider.currentContextAsync()
        return composite.isSatisfiedBy(ctx)
    }
}
```

### Usage Examples
_No content available for this section._

### Basic Auto-Context Specification
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "new_feature_enabled")
)
struct NewFeatureSpec: Specification {
    typealias T = EvaluationContext
}

// Usage with isSatisfied
let spec = NewFeatureSpec()
if try await spec.isSatisfied {
    showNewFeature()
}
```

### Complex Eligibility Specification
```swift
@AutoContext
@specs(
    TimeSinceEventSpec(eventKey: "user_registered", days: 30),
    FeatureFlagSpec(flagKey: "email_verified"),
    MaxCountSpec.dailyLimit("premium_actions", limit: 100),
    CooldownIntervalSpec(eventKey: "last_violation", days: 90)
)
struct PremiumEligibilitySpec: Specification {
    typealias T = EvaluationContext
}

func checkEligibility() async throws -> Bool {
    let spec = PremiumEligibilitySpec()
    return try await spec.isSatisfied
}
```

### Feature Gate with Auto-Context
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "experimental_ui"),
    UserSegmentSpec(expectedSegment: .beta)
)
struct ExperimentalUIAccessSpec: Specification {
    typealias T = EvaluationContext
}

func loadAppInterface() async {
    do {
        if try await ExperimentalUIAccessSpec().isSatisfied {
            loadExperimentalUI()
        } else {
            loadStandardUI()
        }
    } catch {
        // Handle error - fall back to standard UI
        loadStandardUI()
    }
}
```

### API Access Control
```swift
@AutoContext
@specs(
    MaxCountSpec.dailyLimit("api_calls", limit: 10000),
    MaxCountSpec(counterKey: "hourly_calls", maximumCount: 1000),
    FeatureFlagSpec(flagKey: "api_enabled"),
    CooldownIntervalSpec(eventKey: "rate_limit_violation", minutes: 5)
)
struct APIAccessSpec: Specification {
    typealias T = EvaluationContext
}

func canMakeAPICall() async throws -> Bool {
    return try await APIAccessSpec().isSatisfied
}

func performAPICall() async throws {
    guard try await canMakeAPICall() else {
        throw APIError.rateLimitExceeded
    }

    // Make API call
    let response = try await apiClient.request()

    // Track usage
    DefaultContextProvider.shared.incrementCounter("api_calls")
    DefaultContextProvider.shared.incrementCounter("hourly_calls")

    return response
}
```

### Real-World Examples
_No content available for this section._

### Subscription Access Manager
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "subscription_active"),
    DateComparisonSpec(
        eventKey: "subscription_start",
        comparison: .before,
        date: Date()
    ),
    MaxCountSpec(counterKey: "payment_failures", maximumCount: 0)
)
struct ActiveSubscriptionSpec: Specification {
    typealias T = EvaluationContext
}

@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "subscription_cancelled").not(),
    DateComparisonSpec(
        eventKey: "subscription_end",
        comparison: .after,
        date: Date()
    )
)
struct ValidSubscriptionPeriodSpec: Specification {
    typealias T = EvaluationContext
}

class SubscriptionManager {
    func checkAccess() async throws -> AccessLevel {
        let isActive = try await ActiveSubscriptionSpec().isSatisfied
        let isValid = try await ValidSubscriptionPeriodSpec().isSatisfied

        if isActive && isValid {
            return .full
        } else if isValid {
            return .gracePeriod
        } else {
            return .none
        }
    }
}
```

### Content Moderation System
```swift
@AutoContext
@specs(
    MaxCountSpec(counterKey: "content_warnings", maximumCount: 3),
    MaxCountSpec(counterKey: "community_reports", maximumCount: 10),
    TimeSinceEventSpec(eventKey: "last_suspension", days: 90),
    FeatureFlagSpec(flagKey: "account_suspended").not()
)
struct CanPostContentSpec: Specification {
    typealias T = EvaluationContext
}

@AutoContext
@specs(
    MaxCountSpec(counterKey: "moderation_flags", maximumCount: 1),
    CooldownIntervalSpec(eventKey: "last_flagged_post", hours: 24),
    FeatureFlagSpec(flagKey: "auto_moderation_enabled").not()
)
struct RequiresModerationSpec: Specification {
    typealias T = EvaluationContext
}

class ContentManager {
    func submitPost(_ content: String) async throws {
        let canPost = try await CanPostContentSpec().isSatisfied

        guard canPost else {
            throw ContentError.postingRestricted
        }

        let needsModeration = try await RequiresModerationSpec().isSatisfied

        if needsModeration {
            await queueForModeration(content)
        } else {
            await publishImmediately(content)
        }
    }
}
```

### Feature Rollout Controller
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "feature_enabled"),
    DateRangeSpec(start: rolloutStart, end: rolloutEnd),
    UserSegmentSpec(expectedSegment: .beta)
)
struct BetaFeatureSpec: Specification {
    typealias T = EvaluationContext
}

@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "feature_enabled"),
    DateComparisonSpec(eventKey: "general_availability_date", comparison: .after, date: Date())
)
struct GAFeatureSpec: Specification {
    typealias T = EvaluationContext
}

class FeatureRolloutManager {
    func determineFeatureAvailability() async throws -> FeatureAvailability {
        let isBetaUser = try await BetaFeatureSpec().isSatisfied
        let isGA = try await GAFeatureSpec().isSatisfied

        if isGA {
            return .generallyAvailable
        } else if isBetaUser {
            return .betaAccess
        } else {
            return .unavailable
        }
    }

    func enableFeatureIfAvailable() async {
        do {
            let availability = try await determineFeatureAvailability()

            switch availability {
            case .generallyAvailable:
                enableFeature(withBadge: nil)
            case .betaAccess:
                enableFeature(withBadge: "BETA")
            case .unavailable:
                showComingSoonMessage()
            }
        } catch {
            logError("Feature availability check failed: \(error)")
            showComingSoonMessage()
        }
    }
}
```

### Multi-Tier Access Control
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "free_tier")
)
struct FreeTierSpec: Specification {
    typealias T = EvaluationContext
}

@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "premium_subscription"),
    MaxCountSpec(counterKey: "premium_features_used", maximumCount: 100)
)
struct PremiumTierSpec: Specification {
    typealias T = EvaluationContext
}

@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "enterprise_subscription"),
    FeatureFlagSpec(flagKey: "dedicated_support")
)
struct EnterpriseTierSpec: Specification {
    typealias T = EvaluationContext
}

class TierManager {
    func getCurrentTier() async throws -> UserTier {
        if try await EnterpriseTierSpec().isSatisfied {
            return .enterprise
        } else if try await PremiumTierSpec().isSatisfied {
            return .premium
        } else if try await FreeTierSpec().isSatisfied {
            return .free
        } else {
            return .none
        }
    }

    func getFeatureAccess() async throws -> [Feature] {
        let tier = try await getCurrentTier()

        switch tier {
        case .enterprise:
            return Feature.allCases
        case .premium:
            return Feature.premiumFeatures
        case .free:
            return Feature.freeFeatures
        case .none:
            return []
        }
    }
}
```

### Combining with Property Wrappers
- Use @AutoContext specifications with property wrappers for clean integration:
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "new_ui_enabled")
)
struct NewUISpec: Specification {
    typealias T = EvaluationContext
}

// Use with @Satisfies
@Satisfies(using: NewUISpec())
var shouldShowNewUI: Bool

// Or evaluate directly
func checkNewUI() async throws -> Bool {
    return try await NewUISpec().isSatisfied
}
```

### SwiftUI Integration
- Use @AutoContext specifications in SwiftUI views:
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "premium_features"),
    TimeSinceEventSpec(eventKey: "subscription_start", days: 0)
)
struct PremiumAccessSpec: Specification {
    typealias T = EvaluationContext
}

struct ContentView: View {
    @State private var hasPremiumAccess = false
    @State private var isLoading = true

    var body: some View {
        Group {
            if isLoading {
                ProgressView("Checking access...")
            } else if hasPremiumAccess {
                PremiumContentView()
            } else {
                FreeContentView()
            }
        }
        .task {
            await checkAccess()
        }
    }

    func checkAccess() async {
        isLoading = true
        defer { isLoading = false }

        do {
            hasPremiumAccess = try await PremiumAccessSpec().isSatisfied
        } catch {
            hasPremiumAccess = false
            print("Access check failed: \(error)")
        }
    }
}
```

### Error Handling
- Handle errors from async specification evaluation:
```swift
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "feature_enabled")
)
struct FeatureSpec: Specification {
    typealias T = EvaluationContext
}

func checkFeature() async {
    do {
        let isEnabled = try await FeatureSpec().isSatisfied

        if isEnabled {
            enableFeature()
        } else {
            disableFeature()
        }
    } catch {
        // Handle error - use safe default
        disableFeature()
        logError("Feature check failed: \(error)")
    }
}
```

### Testing
- Test @AutoContext specifications using the standard provider:
```swift
func testAutoContextSpec() async throws {
    @AutoContext
    @specs(
        FeatureFlagSpec(flagKey: "test_feature")
    )
    struct TestSpec: Specification {
        typealias T = EvaluationContext
    }

    // Set up test state
    DefaultContextProvider.shared.setFlag("test_feature", to: true)

    // Test using isSatisfied
    let spec = TestSpec()
    let result = try await spec.isSatisfied

    XCTAssertTrue(result)

    // Test with flag disabled
    DefaultContextProvider.shared.setFlag("test_feature", to: false)
    let result2 = try await spec.isSatisfied

    XCTAssertFalse(result2)
}
```

### Future Enhancements
- The @AutoContext macro is designed to support future features:

### Custom Provider Types (Planned)
```swift
// Future: Custom provider type
@AutoContext(CustomProvider.self)
struct MySpec: Specification {
    typealias T = CustomContext
}
```

### SwiftUI Environment Integration (Planned)
```swift
// Future: Environment-based provider
@AutoContext(environment)
struct MySpec: Specification {
    typealias T = EvaluationContext
}
```

### Provider Inference (Planned)
```swift
// Future: Infer provider from context type
@AutoContext(infer)
struct MySpec: Specification {
    typealias T = CustomContext
}
```
- Note: These features emit informative warnings when used, indicating they are recognized but not yet implemented.

### Best Practices
_No content available for this section._

### Always Use with @specs
```swift
// ✅ Good - combined with @specs
@AutoContext
@specs(
    FeatureFlagSpec(flagKey: "enabled")
)
struct MySpec: Specification {
    typealias T = EvaluationContext
}

// ❌ Less useful - @AutoContext alone doesn't add much value
@AutoContext
struct MySpec: Specification {
    typealias T = EvaluationContext

    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {
        // Manual implementation
        return candidate.flag(for: "enabled")
    }
}
```

### Handle Async Errors Appropriately
```swift
// ✅ Good - proper error handling
func checkAccess() async -> Bool {
    do {
        return try await AccessSpec().isSatisfied
    } catch {
        logError(error)
        return false  // Safe default
    }
}

// ❌ Avoid - ignoring errors
func checkAccess() async -> Bool {
    return (try? await AccessSpec().isSatisfied) ?? false
    // Lost error information
}
```

### Use Descriptive Specification Names
```swift
// ✅ Good - clear purpose
@AutoContext
@specs(...)
struct PremiumContentAccessSpec: Specification {
    typealias T = EvaluationContext
}

// ❌ Avoid - unclear naming
@AutoContext
@specs(...)
struct Spec1: Specification {
    typealias T = EvaluationContext
}
```

### Performance Considerations
- Shared Provider: Uses singleton `DefaultContextProvider.shared` (no allocation overhead)
- Async Evaluation: `isSatisfied` property uses async context fetching
- Compile-Time: Macro expansion happens at compile time (no runtime overhead)
- Type Erasure: Minimal overhead from `AnySpecification` usage

### Comparison with Manual Provider Management
_No content available for this section._

### Manual Provider Management
```swift
struct ManualSpec: Specification {
    typealias T = EvaluationContext

    func isSatisfiedBy(_ candidate: EvaluationContext) -> Bool {
        // Implementation...
        return true
    }

    // Manual evaluation helper
    static func evaluate() -> Bool {
        let context = DefaultContextProvider.shared.currentContext()
        return Self().isSatisfiedBy(context)
    }
}

// Usage
if ManualSpec.evaluate() {
    // Do something
}
```

### With @AutoContext Macro
```swift
@AutoContext
@specs(...)
struct AutoSpec: Specification {
    typealias T = EvaluationContext
}

// Usage - cleaner async API
if try await AutoSpec().isSatisfied {
    // Do something
}
```

## Topics

### Related Macros
- doc://specificationcore.SpecificationCore/documentation/SpecificationCore/SpecsMacro

## References

### @specs Macro
- **Kind:** article
- **Identifier:** doc://specificationcore.SpecificationCore/documentation/SpecificationCore/SpecsMacro
